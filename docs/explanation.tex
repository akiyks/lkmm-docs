\section{Explanation of the Linux-Kernel Memory Consistency Model}

\begin{Note}
\begin{description}
\item[Author] Alan Stern \tco{mailto:stern@rowland.harvard.edu}
\item[Created] October 2017
\end{description}
\end{Note}

\subsection{Introduction}

The Linux-kernel memory consistency model (LKMM) is rather complex and
obscure.
This is particularly evident if you read through the
\path{linux-kernel.bell} and \path{linux-kernel.cat} files that
make up the formal version of the model; they are extremely terse and
their meanings are far from clear.

This document describes the ideas underlying the LKMM\@.
It is meant for people who want to understand how the model was designed.
It does not go into the details of the code in the \path{.bell} and
\path{.cat} files; rather, it explains in English what the code
expresses symbolically.

\Crefthro{sec:docs:explanation:Background}%
  {sec:docs:explanation:Ordering and Cycles} are aimed
toward beginners; they explain what memory consistency models are and
the basic notions shared by all such models.
People already familiar with these concepts can skim or skip over them.
\Crefthro{sec:docs:explanation:Events}%
 {sec:docs:explanation:The From-reads Relation: fr, fri, and fre}
describe the fundamental relations used in many models.
Starting in \cref{sec:docs:explanation:An Operational Model},
the workings of the LKMM itself are covered.

\begin{Warn}
  Warning:
  The code examples in this document are not written in the proper format
  for litmus tests.
  They don't include a header line, the initializations are not enclosed
  in braces, the global variables are not passed by pointers, and they
  don't have an \qco{exists} clause at the end.
  Converting them to the right format is left as an exercise for the reader.
\end{Warn}

\subsection{Background}
\label{sec:docs:explanation:Background}

A memory consistency model (or just memory model, for short) is
something which predicts, given a piece of computer code running on a
particular kind of system, what values may be obtained by the code's
load instructions.
The LKMM makes these predictions for code running as part of the Linux
kernel.

In practice, people tend to use memory models the other way around.
That is, given a piece of code and a collection of values specified
for the loads, the model will predict whether it is possible for the
code to run in such a way that the loads will indeed obtain the
specified values.
Of course, this is just another way of expressing the same idea.

For code running on a uniprocessor system, the predictions are easy:
Each load instruction must obtain the value written by the most recent
store instruction accessing the same location (we ignore complicating
factors such as DMA and mixed-size accesses.)
But on multiprocessor systems, with multiple CPUs making concurrent
accesses to shared memory locations, things aren't so simple.

Different architectures have differing memory models, and the Linux
kernel supports a variety of architectures.
The LKMM has to be fairly permissive, in the sense that any behavior
allowed by one of these architectures also has to be allowed by the LKMM\@.


\subsection{A simple example}
\label{sec:docs:explanation:A Simple Example}

Here is a simple example to illustrate the basic concepts.
Consider some code running as part of a device driver for an input device.
The driver might contain an interrupt handler which collects data from the
device, stores it in a buffer, and sets a flag to indicate the buffer
is full.
Running concurrently on a different CPU might be a part of the driver
code being executed by a process in the midst of a \co{read(2)}
system call.
This code tests the flag to see whether the buffer is ready, and if it is,
copies the data back to userspace.
The buffer and the flag are memory locations shared between the two CPUs.

We can abstract out the important pieces of the driver code as follows
(the reason for using \co{WRITE_ONCE()} and \co{READ_ONCE()} instead of
simple assignment statements is discussed later):

\begin{VerbatimU}
	int buf = 0, flag = 0;

	P0()
	{
		WRITE_ONCE(buf, 1);
		WRITE_ONCE(flag, 1);
	}

	P1()
	{
		int r1;
		int r2 = 0;

		r1 = READ_ONCE(flag);
		if (r1)
			r2 = READ_ONCE(buf);
	}
\end{VerbatimU}

Here the \co{P0()} function represents the interrupt handler running on one
CPU and \co{P1()} represents the \co{read()} routine running on another.
The value~1 stored in \co{buf} represents input data collected from the device.
Thus, \co{P0} stores the data in \co{buf} and then sets \co{flag}.
Meanwhile, \co{P1} reads \co{flag} into the private variable \co{r1},
and if it is set, reads the data from \co{buf} into a second private
variable \co{r2} for copying to userspace.
(Presumably if \co{flag} is not set then the driver will wait a while
and try again.)

This pattern of memory accesses, where one CPU stores values to two
shared memory locations and another CPU loads from those locations in
the opposite order, is widely known as the ``Message Passing'' or MP
pattern.
It is typical of memory access patterns in the kernel.

Please note that this example code is a simplified abstraction.
Real buffers are usually larger than a single integer, real device drivers
usually use sleep and wakeup mechanisms rather than polling for I/O
completion, and real code generally doesn't bother to copy values into
private variables before using them.
All that is beside the point; the idea here is simply to illustrate the
overall pattern of memory accesses by the CPUs.

A memory model will predict what values \co{P1} might obtain for its loads
from \co{flag} and \co{buf}, or equivalently, what values \co{r1} and
\co{r2} might end up with after the code has finished running.

Some predictions are trivial.
For instance, no sane memory model would predict that \qco{r1 = 42} or
\qco{r2 = -7}, because neither of those values ever gets stored in
\co{flag} or \co{buf}.

Some nontrivial predictions are nonetheless quite simple.
For instance, \co{P1} might run entirely before \co{P0} begins, in which
case \co{r1} and \co{r2} will both be~0 at the end.
Or \co{P0} might run entirely before \co{P1} begins, in which case
\co{r1} and \co{r2} will both be~1.

The interesting predictions concern what might happen when the two
routines run concurrently.
One possibility is that \co{P1} runs after \co{P0}'s store to \co{buf}
but before the store to \co{flag}.
In this case, \co{r1} and \co{r2} will again both be~0.
(If \co{P1} had been designed to read \co{buf} unconditionally then we
would instead have \qco{r1 = 0} and \qco{r2 = 1}.)

However, the most interesting possibility is where \qco{r1 = 1} and
\qco{r2 = 0}.
If this were to occur it would mean the driver contains a bug, because
incorrect data would get sent to the user:
0~instead of~1.
As it happens, the LKMM does predict this outcome can occur, and the example
driver code shown above is indeed buggy.


\subsection{A selection of memory models}

The first widely cited memory model, and the simplest to understand,
is Sequential Consistency.
According to this model, systems behave as if each CPU executed its
instructions in order but with unspecified timing.
In other words, the instructions from the various CPUs get interleaved
in a nondeterministic way, always according to some single global order
that agrees with the order of the instructions in the program source for
each CPU\@.
The model says that the value obtained by each load is simply the value
written by the most recently executed store to the same memory location,
from any CPU\@.

For the MP example code shown above, Sequential Consistency predicts
that the undesired result \qco{r1 = 1, r2 = 0} cannot occur.
The reasoning goes like this:

\begin{quote}
  Since \qco{r1 = 1}, \co{P0} must store~1 to \co{flag} before \co{P1}
  loads~1 from it, as loads can obtain values only from earlier stores.

  \co{P1} loads from \co{flag} before loading from \co{buf}, since CPUs
  execute their instructions in order.

  \co{P1} must load~0 from \co{buf} before \co{P0} stores~1 to it;
  otherwise \co{r2} would be~1 since a load obtains its value from the
  most recent store to the same address.

  \co{P0} stores~1 to \co{buf} before storing~1 to \co{flag}, since it
  executes its instructions in order.

  Since an instruction (in this case, \co{P0}'s store to \co{flag})
  cannot execute before itself, the specified outcome is impossible.
\end{quote}

However, real computer hardware almost never follows the Sequential
Consistency memory model; doing so would rule out too many valuable
performance optimizations.
On ARM and PowerPC architectures, for instance, the MP example code
really does sometimes yield \qco{r1 = 1} and \qco{r2 = 0}.

x86 and SPARC follow yet a different memory model:
TSO (Total Store Ordering).
This model predicts that the undesired outcome for the MP pattern
cannot occur, but in other respects it differs from Sequential
Consistency.
One example is the Store Buffer (SB) pattern, in which each CPU
stores to its own shared location and then loads from the other CPU's
location:

\begin{VerbatimU}
	int x = 0, y = 0;

	P0()
	{
		int r0;

		WRITE_ONCE(x, 1);
		r0 = READ_ONCE(y);
	}

	P1()
	{
		int r1;

		WRITE_ONCE(y, 1);
		r1 = READ_ONCE(x);
	}
\end{VerbatimU}

Sequential Consistency predicts that the outcome \qco{r0 = 0, r1 = 0} is
impossible.
(Exercise:
Figure out the reasoning.)
But TSO allows this outcome to occur, and in fact it does sometimes
occur on x86 and SPARC systems.

The LKMM was inspired by the memory models followed by PowerPC, ARM,
x86, Alpha, and other architectures.
However, it is different in detail from each of them.


\subsection{Ordering and cycles}
\label{sec:docs:explanation:Ordering and Cycles}

Memory models are all about ordering.
Often this is temporal ordering (i.e., the order in which certain
events occur) but it doesn't have to be; consider for example the
order of instructions in a program's source code.
We saw above that Sequential Consistency makes an important assumption
that CPUs execute instructions in the same order as those instructions
occur in the code, and there are many other instances of ordering
playing central roles in memory models.

The counterpart to ordering is a cycle.
Ordering rules out cycles:
It's not possible to have X~ordered before~Y, Y~ordered before~Z, and
Z~ordered before~X, because this would mean that X~is ordered before
itself.
The analysis of the MP example under Sequential Consistency involved
just such an impossible cycle:

\begin{VerbatimU}
	W: P0 stores 1 to flag   executes before
	X: P1 loads 1 from flag  executes before
	Y: P1 loads 0 from buf   executes before
	Z: P0 stores 1 to buf    executes before
	W: P0 stores 1 to flag.
\end{VerbatimU}

In short, if a memory model requires certain accesses to be ordered,
and a certain outcome for the loads in a piece of code can happen only
if those accesses would form a cycle, then the memory model predicts
that outcome cannot occur.

The LKMM is defined largely in terms of cycles, as we will see.


\subsection{Events}
\label{sec:docs:explanation:Events}

The LKMM does not work directly with the C~statements that make up
kernel source code.
Instead it considers the effects of those statements in a more
abstract form, namely, events.
The model includes three types of events:

\begin{itemize}
\item	Read events correspond to loads from shared memory, such as
	calls to \co{READ_ONCE()}, \co{smp_load_acquire()}, or
	\co{rcu_dereference()}.

\item	Write events correspond to stores to shared memory, such as
	calls to \co{WRITE_ONCE()}, \co{smp_store_release()}, or
	\co{atomic_set()}.

\item	Fence events correspond to memory barriers (also known as
	fences), such as calls to \co{smp_rmb()} or \co{rcu_read_lock()}.
\end{itemize}

These categories are not exclusive; a read or write event can also be
a fence.
This happens with functions like \co{smp_load_acquire()} or \co{spin_lock()}.
However, no single event can be both a read and a write.
Atomic read-modify-write accesses, such as \co{atomic_inc()} or \co{xchg()},
correspond to a pair of events: a read followed by a write.
(The write event is omitted for executions where it doesn't occur,
such as a \co{cmpxchg()} where the comparison fails.)

Other parts of the code, those which do not involve interaction with
shared memory, do not give rise to events.
Thus, arithmetic and logical computations, control-flow instructions,
or accesses to private memory or CPU registers are not of central
interest to the memory model.
They only affect the model's predictions indirectly.
For example, an arithmetic computation might determine the value that
gets stored to a shared memory location (or in the case of an array
index, the address where the value gets stored), but the memory model
is concerned only with the store itself---its value and its
address---not the computation leading up to it.

Events in the LKMM can be linked by various relations, which we will
describe in the following sections.
The memory model requires certain of these relations to be orderings,
that is, it requires them not to have any cycles.


\subsection{The program order relation: \co{po} and \co{po-loc}}
\label{sec:docs:explanation:The Program Order Relation: po and po-loc}

The most important relation between events is program order (\co{po}).
You can think of it as the order in which statements occur in the source
code after branches are taken into account and loops have been
unrolled.
A better description might be the order in which instructions are
presented to a CPU's execution unit.
Thus, we say that X~is \co{po}-before~Y (written as \qtco{X ->po Y} in
formulas) if X~occurs before~Y in the instruction stream.

This is inherently a single-CPU relation; two instructions executing
on different CPUs are never linked by \co{po}.
Also, it is by definition an ordering so it cannot have any cycles.

\co{po-loc} is a sub-relation of \co{po}.
It links two memory accesses when the first comes before the second
in program order and they access the same memory location (the \qco{-loc}
suffix).

Although this may seem straightforward, there is one subtle aspect to
program order we need to explain.
The LKMM was inspired by low-level architectural memory models which
describe the behavior of machine code, and it retains their outlook
to a considerable extent.
The read, write, and fence events used by the model are close in spirit
to individual machine instructions.
Nevertheless, the LKMM describes kernel code written in~C, and the
mapping from~C to machine code can be extremely complex.

Optimizing compilers have great freedom in the way they translate
source code to object code.
They are allowed to apply transformations that add memory accesses,
eliminate accesses, combine them, split them into pieces, or move them
around.
The use of \co{READ_ONCE()}, \co{WRITE_ONCE()}, or one of the other
atomic or synchronization primitives prevents a large number of
compiler optimizations.
In particular, it is guaranteed that the compiler will not remove such
accesses from the generated code (unless it can prove the accesses will
never be executed), it will not change the order in which they occur
in the code (within limits imposed by the C~standard), and it will not
introduce extraneous accesses.

The MP and SB examples above used \co{READ_ONCE()} and \co{WRITE_ONCE()}
rather than ordinary memory accesses.
Thanks to this usage, we can be certain that in the MP example, the
compiler won't reorder \co{P0}'s write event to~\co{buf} and \co{P0}'s write
event to~\co{flag}, and similarly for the other shared memory accesses
in the examples.

Since private variables are not shared between CPUs, they can be
accessed normally without \co{READ_ONCE()} or \co{WRITE_ONCE()}.
In fact, they need not even be stored in normal memory at
all---in principle a private variable could be stored in a CPU
register (hence the convention that these variables have names
starting with the letter `\co{r}').


\subsection{A warning}
\label{sec:docs:explanation:A Warning}

The protections provided by \co{READ_ONCE()}, \co{WRITE_ONCE()}, and
others are not perfect; and under some circumstances it is possible
for the compiler to undermine the memory model.
Here is an example.
Suppose both branches of an \qco{if} statement store the same value
to the same location:

\begin{VerbatimU}
	r1 = READ_ONCE(x);
	if (r1) {
		WRITE_ONCE(y, 2);
		...  /* do something */
	} else {
		WRITE_ONCE(y, 2);
		...  /* do something else */
	}
\end{VerbatimU}

For this code, the LKMM predicts that the load from~\co{x} will always be
executed before either of the stores to~\co{y}.
However, a compiler could lift the stores out of the conditional,
transforming the code into something resembling:

\begin{VerbatimU}
	r1 = READ_ONCE(x);
	WRITE_ONCE(y, 2);
	if (r1) {
		...  /* do something */
	} else {
		...  /* do something else */
	}
\end{VerbatimU}

Given this version of the code, the LKMM would predict that the load
from~\co{x} could be executed after the store to~\co{y}.
Thus, the memory model's original prediction could be invalidated
by the compiler.

Another issue arises from the fact that in~C, arguments to many
operators and function calls can be evaluated in any order.
For example:

\begin{VerbatimU}
	r1 = f(5) + g(6);
\end{VerbatimU}

The object code might call \co{f(5)} either before or after \co{g(6)}; the
memory model cannot assume there is a fixed program order relation
between them.
(In fact, if the function calls are inlined then the compiler might
even interleave their object code.)


\subsection{Dependency relations: \co{data}, \co{addr}, and \co{ctrl}}
\label{sec:docs:explanation:Dependency Relations: data, addr, and ctrl}

We say that two events are linked by a dependency relation when the
execution of the second event depends in some way on a value obtained
from memory by the first.
The first event must be a read, and the value it obtains must somehow
affect what the second event does.
There are three kinds of dependencies: \co{data}, address (\co{addr}),
and control (\co{ctrl}).

A read and a write event are linked by a data dependency if the value
obtained by the read affects the value stored by the write.
As a very simple example:

\begin{VerbatimU}
	int x, y;

	r1 = READ_ONCE(x);
	WRITE_ONCE(y, r1 + 5);
\end{VerbatimU}

The value stored by the \co{WRITE_ONCE} obviously depends on the value
loaded by the \co{READ_ONCE}.
Such dependencies can wind through arbitrarily complicated
computations, and a write can depend on the values of multiple reads.

A read event and another memory access event are linked by an address
dependency if the value obtained by the read affects the location
accessed by the other event.
The second event can be either a read or a write.
Here's another simple example:

\begin{VerbatimU}
	int a[20];
	int i;

	r1 = READ_ONCE(i);
	r2 = READ_ONCE(a[r1]);
\end{VerbatimU}

Here the location accessed by the second \co{READ_ONCE()} depends on the
index value loaded by the first.
Pointer indirection also gives rise to address dependencies, since
the address of a location accessed through a pointer will depend on
the value read earlier from that pointer.

Finally, a read event~X and a write event~Y are linked by a control
dependency if Y~syntactically lies within an arm of an \co{if} statement
and X~affects the evaluation of the \co{if} condition via a data or address
dependency (or similarly for a switch statement).
Simple example:

\begin{VerbatimU}
	int x, y;

	r1 = READ_ONCE(x);
	if (r1)
		WRITE_ONCE(y, 1984);
\end{VerbatimU}

Execution of the \co{WRITE_ONCE()} is controlled by a conditional expression
which depends on the value obtained by the \co{READ_ONCE()}; hence there is
a control dependency from the load to the store.

It should be pretty obvious that events can only depend on reads that
come earlier in program order.
Symbolically, if we have \qtco{R ->data X}, \qtco{R ->addr X}, or
\qtco{R ->ctrl X} (where \co{R} is a read event), then we must also
have \qtco{R ->po X}.
It wouldn't make sense for a computation to depend somehow on a value
that doesn't get loaded from shared memory until later in the code!

Here's a trick question:
When is a dependency not a dependency?
Answer:
When it is purely syntactic rather than semantic.
We say a dependency between two accesses is purely syntactic if the
second access doesn't actually depend on the result of the first.
Here is a trivial example:

\begin{VerbatimU}
	r1 = READ_ONCE(x);
	WRITE_ONCE(y, r1 * 0);
\end{VerbatimU}

There appears to be a data dependency from the load of~\co{x} to the store
of~\co{y}, since the value to be stored is computed from the value that was
loaded.
But in fact, the value stored does not really depend on anything since
it will always be~0.
Thus the data dependency is only syntactic (it appears to exist in the
code) but not semantic (the second access will always be the same,
regardless of the value of the first access).
Given code like this, a compiler could simply discard the value
returned by the load from~\co{x}, which would certainly destroy
any dependency.
(The compiler is not permitted to eliminate entirely the load generated
for a \co{READ_ONCE()}---that's one of the nice properties of
\co{READ_ONCE()}---but it is allowed to ignore the load's value.)

It's natural to object that no one in their right mind would write
code like the above.
However, macro expansions can easily give rise to this sort of thing,
in ways that often are not apparent to the programmer.

Another mechanism that can lead to purely syntactic dependencies is
related to the notion of ``undefined behavior''.
Certain program behaviors are called ``undefined'' in the C~language
specification, which means that when they occur there are no
guarantees at all about the outcome.
Consider the following example:

\begin{VerbatimU}
	int a[1];
	int i;

	r1 = READ_ONCE(i);
	r2 = READ_ONCE(a[r1]);
\end{VerbatimU}

Access beyond the end or before the beginning of an array is one kind
of undefined behavior.
Therefore the compiler doesn't have to worry about what will happen
if \co{r1} is nonzero, and it can assume that \co{r1} will always be
zero regardless of the value actually loaded from~\co{i}.
(If the assumption turns out to be wrong the resulting behavior will
be undefined anyway, so the compiler doesn't care!)
Thus the value from the load can be discarded, breaking the address
dependency.

The LKMM is unaware that purely syntactic dependencies are different
from semantic dependencies and therefore mistakenly predicts that the
accesses in the two examples above will be ordered.
This is another example of how the compiler can undermine the memory
model.
Be warned.


\subsection{The reads-from relation: \co{rf}, \co{rfi}, and \co{rfe}}
\label{sec:docs:explanation:The Reads-from Relation: rf, rfi, and rfe}

The reads-from relation (\co{rf}) links a write event to a read event when
the value loaded by the read is the value that was stored by the
write.
In colloquial terms, the load ``reads from'' the store.
We write \qtco{W ->rf R} to indicate that the load~\co{R} reads from
the store~\co{W}.
We further distinguish the cases where the load and the store occur on
the same CPU (internal reads-from, or \co{rfi}) and where they occur on
different CPUs (external reads-from, or \co{rfe}).

For our purposes, a memory location's initial value is treated as
though it had been written there by an imaginary initial store that
executes on a separate CPU before the main program runs.

Usage of the \co{rf} relation implicitly assumes that loads will always
read from a single store.
It doesn't apply properly in the presence of load-tearing, where a
load obtains some of its bits from one store and some of them from
another store.
Fortunately, use of \co{READ_ONCE()} and \co{WRITE_ONCE()} will
prevent load-tearing; it's not possible to have:

\begin{VerbatimU}
	int x = 0;

	P0()
	{
		WRITE_ONCE(x, 0x1234);
	}

	P1()
	{
		int r1;

		r1 = READ_ONCE(x);
	}
\end{VerbatimU}

\noindent%
and end up with \qco{r1 = 0x1200} (partly from \co{x}'s initial value
and partly from the value stored by~\co{P0}).

On the other hand, load-tearing is unavoidable when mixed-size
accesses are used.
Consider this example:

\begin{VerbatimU}
	union {
		u32	w;
		u16	h[2];
	} x;

	P0()
	{
		WRITE_ONCE(x.h[0], 0x1234);
		WRITE_ONCE(x.h[1], 0x5678);
	}

	P1()
	{
		int r1;

		r1 = READ_ONCE(x.w);
	}
\end{VerbatimU}

If \qco{r1 = 0x56781234} (little-endian{!}) at the end, then \co{P1}
must have read from both of \co{P0}'s stores.
It is possible to handle mixed-size and unaligned accesses in a memory
model, but the LKMM currently does not attempt to do so.
It requires all accesses to be properly aligned and of the location's
actual size.


\subsection{Cache coherence and the coherence order relation: \co{co}, \co{coi}, and \co{coe}}
\label{sec:docs:explanation:Cache Coherence and The Coherence Order Relation}

Cache coherence is a general principle requiring that in a
multi-processor system, the CPUs must share a consistent view of the
memory contents.
Specifically, it requires that for each location in shared memory,
the stores to that location must form a single global ordering which
all the CPUs agree on (the coherence order), and this ordering must be
consistent with the program order for accesses to that location.

To put it another way, for any variable~\co{x}, the coherence order
(\co{co}) of the stores to~\co{x} is simply the order in which the
stores overwrite one another.
The imaginary store which establishes \co{x}'s initial value
comes first in the coherence order; the store which directly
overwrites the initial value comes second; the store which overwrites
that value comes third, and so on.

You can think of the coherence order as being the order in which the
stores reach \co{x}'s location in memory (or if you prefer a more
hardware-centric view, the order in which the stores get written to
\co{x}'s cache line).
We write \qtco{W ->co W'} if \co{W}~comes before~\co{W'} in the
coherence order, that is, if the value stored by~\co{W} gets overwritten,
directly or indirectly, by the value stored by~\co{W'}.

Coherence order is required to be consistent with program order.
This requirement takes the form of four coherency rules:

\begin{itemize}
\item	Write-write coherence:
	If \qtco{W ->po-loc W'} (i.e., \co{W}~comes before \co{W'} in
	program order and they access the same location), where \co{W}
	and \co{W'} are two stores, then \qtco{W ->co W'}.

\item	Write-read coherence:
	If \qtco{W ->po-loc R}, where \co{W}~is a store and \co{R}~is
	a load, then \co{R}~must read from~\co{W} or from some other
	store which comes after~\co{W} in the coherence order.

\item	Read-write coherence:
	If \qtco{R ->po-loc W}, where \co{R}~is a load and \co{W}~is
	a store, then the store which \co{R}~reads from must come
	before~\co{W} in the coherence order.

\item	Read-read coherence:
	If \qtco{R ->po-loc R'}, where \co{R}~and \co{R'} are two loads,
	then either they read from the same store or else the store
	read by~\co{R} comes before the store read by~\co{R'} in the
	coherence order.
\end{itemize}

This is sometimes referred to as sequential consistency per variable,
because it means that the accesses to any single memory location obey
the rules of the Sequential Consistency memory model.
(According to Wikipedia, sequential consistency per variable and cache
coherence mean the same thing except that cache coherence includes an extra
requirement that every store eventually becomes visible to every CPU.)

Any reasonable memory model will include cache coherence.
Indeed, our expectation of cache coherence is so deeply ingrained that
violations of its requirements look more like hardware bugs than
programming errors:

\begin{VerbatimU}
	int x;

	P0()
	{
		WRITE_ONCE(x, 17);
		WRITE_ONCE(x, 23);
	}
\end{VerbatimU}

If the final value stored in~\co{x} after this code ran was~17, you would
think your computer was broken.
It would be a violation of the write-write coherence rule:
Since the store of~23 comes later in program order, it must also come
later in \co{x}'s coherence order and thus must overwrite the store of~17.

\begin{VerbatimU}
	int x = 0;

	P0()
	{
		int r1;

		r1 = READ_ONCE(x);
		WRITE_ONCE(x, 666);
	}
\end{VerbatimU}

If \qco{r1 = 666} at the end, this would violate the read-write coherence
rule:
The \co{READ_ONCE()} load comes before the \co{WRITE_ONCE()} store in
program order, so it must not read from that store but rather from one
coming earlier in the coherence order (in this case, \co{x}'s initial
value).

\begin{VerbatimU}
	int x = 0;

	P0()
	{
		WRITE_ONCE(x, 5);
	}

	P1()
	{
		int r1, r2;

		r1 = READ_ONCE(x);
		r2 = READ_ONCE(x);
	}
\end{VerbatimU}

If \qco{r1 = 5} (reading from \co{P0}'s store) and \qco{r2 = 0}
(reading from the imaginary store which establishes \co{x}'s initial
value) at the end, this would violate the read-read coherence rule:
The \co{r1} load comes before the \co{r2} load in program order, so it
must not read from a store that comes later in the coherence order.

(As a minor curiosity, if this code had used normal loads instead of
\co{READ_ONCE()} in \co{P1}, on Itanium it sometimes could end up with
\qco{r1 = 5} and \qco{r2 = 0}!
This results from parallel execution of the operations encoded in
Itanium's Very-Long-Instruction-Word format, and it is yet another
motivation for using \co{READ_ONCE()} when accessing shared memory
locations.)

Just like the \co{po} relation, \co{co} is inherently an
ordering---it is not possible for a store to directly or indirectly
overwrite itself!
And just like with the \co{rf} relation, we distinguish between stores that
occur on the same CPU (internal coherence order, or \co{coi}) and stores
that occur on different CPUs (external coherence order, or \co{coe}).

On the other hand, stores to different memory locations are never
related by \co{co}, just as instructions on different CPUs are never
related by \co{po}.
Coherence order is strictly per-location, or if you prefer, each
location has its own independent coherence order.


\subsection{The from-reads relation: \co{fr}, \co{fri}, and \co{fre}}
\label{sec:docs:explanation:The From-reads Relation: fr, fri, and fre}

The from-reads relation (\co{fr}) can be a little difficult for people to
grok.
It describes the situation where a load reads a value that gets
overwritten by a store.
In other words, we have \qtco{R ->fr W} when the value that \co{R}~reads
is overwritten (directly or indirectly) by~\co{W}, or equivalently,
when \co{R}~reads from a store which comes earlier than~\co{W} in
the coherence order.

For example:

\begin{VerbatimU}
	int x = 0;

	P0()
	{
		int r1;

		r1 = READ_ONCE(x);
		WRITE_ONCE(x, 2);
	}
\end{VerbatimU}

The value loaded from~\co{x} will be~0 (assuming cache coherence{!}), and it
gets overwritten by the value~2.
Thus there is an \co{fr} link from the \co{READ_ONCE()} to the
\co{WRITE_ONCE()}.
If the code contained any later stores to~\co{x}, there would also be
\co{fr} links from the \co{READ_ONCE()} to them.

As with \co{rf}, \co{rfi}, and \co{rfe}, we subdivide the \co{fr} relation
into \co{fri} (when the load and the store are on the same CPU) and
\co{fre} (when they are on different CPUs).

Note that the \co{fr} relation is determined entirely by the \co{rf} and
\co{co} relations; it is not independent.
Given a read event~\co{R} and a write event~\co{W} for the same
location, we will have \qtco{R ->fr W} if and only if the write
which \co{R}~reads from is \co{co}-before~\co{W}.
In symbols,

\begin{VerbatimU}
	(R ->fr W) := (there exists W' with W' ->rf R and W' ->co W).
\end{VerbatimU}


\subsection{An operational model}
\label{sec:docs:explanation:An Operational Model}

The LKMM is based on various operational memory models, meaning that
the models arise from an abstract view of how a computer system
operates.
Here are the main ideas, as incorporated into the LKMM\@.

The system as a whole is divided into the CPUs and a memory subsystem.
The CPUs are responsible for executing instructions (not necessarily
in program order), and they communicate with the memory subsystem.
For the most part, executing an instruction requires a CPU to perform
only internal operations.
However, loads, stores, and fences involve more.

When CPU~\co{C} executes a store instruction, it tells the memory subsystem
to store a certain value at a certain location.
The memory subsystem propagates the store to all the other CPUs as well
as to RAM\@.
(As a special case, we say that the store propagates to its own CPU at the
time it is executed.)
The memory subsystem also determines where the store falls in the
location's coherence order.
In particular, it must arrange for the store to be \co{co}-later than
(i.e., to overwrite) any other store to the same location which has
already propagated to CPU~\co{C}.

When a CPU executes a load instruction~\co{R}, it first checks to see
whether there are any as-yet unexecuted store instructions,
for the same location, that come before~\co{R} in program order.
If there are, it uses the value of the \co{po}-latest such store as
the value obtained by~\co{R}, and we say that the store's value is
forwarded to~\co{R}.
Otherwise, the CPU asks the memory subsystem for the value to load
and we say that~\co{R} is satisfied from memory.
The memory subsystem hands back the value of the \co{co}-latest store
to the location in question which has already propagated to that CPU\@.

(In fact, the picture needs to be a little more complicated than this.
CPUs have local caches, and propagating a store to a CPU really means
propagating it to the CPU's local cache.
A local cache can take some time to process the stores that it
receives, and a store can't be used to satisfy one of the CPU's loads
until it has been processed.
On most architectures, the local caches process stores in
First-In-First-Out (FIFO) order, and consequently the processing delay
doesn't matter for the memory model.
But on Alpha, the local caches have a partitioned design that results
in non-FIFO behavior.  We will discuss this in more detail later.)

Note that load instructions may be executed speculatively and may be
restarted under certain circumstances.
The memory model ignores these premature executions; we simply say
that the load executes at the final time it is forwarded or satisfied.

Executing a fence (or memory barrier) instruction doesn't require a
CPU to do anything special other than informing the memory subsystem
about the fence.
However, fences do constrain the way CPUs and the memory subsystem
handle other instructions, in two respects.

First, a fence forces the CPU to execute various instructions in
program order.
Exactly which instructions are ordered depends on the type of fence:

\begin{itemize}
\item	Strong fences, including \co{smp_mb()} and \co{synchronize_rcu()}, force
	the CPU to execute all \co{po}-earlier instructions before any
	\co{po}-later instructions;

\item	\co{smp_rmb()} forces the CPU to execute all \co{po}-earlier loads
	before any \co{po}-later loads;

\item	\co{smp_wmb()} forces the CPU to execute all \co{po}-earlier stores
	before any \co{po}-later stores;

\item	Acquire fences, such as \co{smp_load_acquire()}, force the CPU to
	execute the load associated with the fence (e.g., the load
	part of an \co{smp_load_acquire()}) before any \co{po}-later
	instructions;

\item	Release fences, such as \co{smp_store_release()}, force the CPU to
	execute all \co{po}-earlier instructions before the store
	associated with the fence (e.g., the store part of an
	\co{smp_store_release()}).
\end{itemize}

Second, some types of fence affect the way the memory subsystem
propagates stores.
When a fence instruction is executed on CPU \co{C}:

\begin{itemize}
\item	For each other CPU \co{C'}, \co{smp_wmb()} forces all \co{po}-earlier stores
	on~\co{C} to propagate to~\co{C'} before any \co{po}-later stores do.

\item	For each other CPU \co{C'}, any store which propagates to~\co{C} before
	a release fence is executed (including all \co{po}-earlier
	stores executed on~\co{C}) is forced to propagate to~\co{C'} before the
	store associated with the release fence does.

\item	Any store which propagates to~\co{C} before a strong fence is
	executed (including all \co{po}-earlier stores on~\co{C}) is forced to
	propagate to all other CPUs before any instructions \co{po}-after
	the strong fence are executed on~\co{C}.
\end{itemize}

The propagation ordering enforced by release fences and strong fences
affects stores from other CPUs that propagate to CPU~\co{C} before the
fence is executed, as well as stores that are executed on~\co{C} before the
fence.
We describe this property by saying that release fences and
strong fences are A-cumulative.
By contrast, \co{smp_wmb()} fences are not A-cumulative; they only
affect the propagation of stores that are executed on~\co{C} before
the fence (i.e., those which precede the fence in program order).

\co{rcu_read_lock()}, \co{rcu_read_unlock()}, and \co{synchronize_rcu()}
fences have other properties which we discuss later.


\subsection{Propagation order relation: \co{cumul-fence}}
\label{sec:docs:explanation:Propagation Order Releation: cumul-fence}

The fences which affect propagation order (i.e., strong, release, and
\co{smp_wmb()} fences) are collectively referred to as \co{cumul-fence}s, even
though \co{smp_wmb()} isn't A-cumulative.
The \co{cumul-fence} relation is defined to link memory access events~\co{E}
and~\co{F} whenever:

\begin{itemize}
\item	\co{E} and \co{F} are both stores on the same CPU and an \co{smp_wmb()} fence
	event occurs between them in program order; or

\item	\co{F} is a release fence and some \co{X}~comes before~\co{F} in program order,
	where either \qco{X = E} or else \qtco{E ->rf X}; or

\item	A strong fence event occurs between some \co{X} and~\co{F} in program
	order, where either \qco{X = E} or else \qtco{E ->rf X}.
\end{itemize}

The operational model requires that whenever \co{W} and~\co{W'} are both stores
and \qtco{W ->cumul-fence W'}, then \co{W} must propagate to any given CPU
before \co{W'} does.
However, for different CPUs~\co{C} and~\co{C'}, it does not
require \co{W} to propagate to~\co{C} before~\co{W'} propagates to~\co{C'}.


\subsection{Derivation of the LKMM from the operational model}
\label{sec:docs:explanation:Derivation of The LKMM from The Operational Model}

The LKMM is derived from the restrictions imposed by the design
outlined above.
These restrictions involve the necessity of maintaining cache
coherence and the fact that a CPU can't operate on a value before
it knows what that value is, among other things.

The formal version of the LKMM is defined by six requirements, or
axioms:

\begin{itemize}
\item	Sequential consistency per variable:
	This requires that the system obey the four coherency rules.

\item	Atomicity:
	This requires that atomic read-modify-write operations really
	are atomic, that is, no other stores can sneak into the
	middle of such an update.

\item	Happens-before:
	This requires that certain instructions are executed in a
	specific order.

\item	Propagation:
	This requires that certain stores propagate to CPUs and to
	RAM in a specific order.

\item	Rcu:
	This requires that RCU read-side critical sections and
	grace periods obey the rules of RCU, in particular, the
	Grace-Period Guarantee.

\item	Plain-coherence:
	This requires that plain memory accesses (those not using
	\co{READ_ONCE()}, \co{WRITE_ONCE()}, etc.\@) must obey
	the operational model's rules regarding cache coherence.
\end{itemize}

The first and second are quite common; they can be found in many
memory models (such as those for C11/C++11).
The ``happens-before'' and ``propagation'' axioms have analogs
in other memory models as well.
The ``rcu'' and ``plain-coherence'' axioms are specific to the LKMM\@.

Each of these axioms is discussed below.


\subsection{Sequential consistency per variable}
\label{sec:docs:explanation:Sequential Consistency per Variable}

According to the principle of cache coherence, the stores to any fixed
shared location in memory form a global ordering.
We can imagine inserting the loads from that location into this
ordering, by placing each load between the store that it reads from
and the following store.
This leaves the relative positions of loads that read from the same
store unspecified; let's say they are inserted in program order,
first for CPU~0, then CPU~1, etc.

You can check that the four coherency rules imply that the \co{rf}, \co{co}, \co{fr},
and \co{po-loc} relations agree with this global ordering; in other words,
whenever we have \qtco{X ->rf Y} or \qtco{X ->co Y} or \qtco{X ->fr Y} or \qtco{X ->po-loc Y}, the
\co{X}~event comes before the \co{Y}~event in the global ordering.
The LKMM's ``coherence'' axiom expresses this by requiring the union of these
relations not to have any cycles.
This means it must not be possible to find events

\begin{VerbatimU}
	X0 -> X1 -> X2 -> ... -> Xn -> X0
\end{VerbatimU}

\noindent%
where each of the links is either \co{rf}, \co{co}, \co{fr}, or \co{po-loc}.
This has to hold if the accesses to the fixed memory location can be
ordered as cache coherence demands.

Although it is not obvious, it can be shown that the converse is also
true:
This LKMM axiom implies that the four coherency rules are obeyed.


\subsection{Atomic updates: \co{rmw}}
\label{sec:docs:explanation:Atomic Updates: rmw}

What does it mean to say that a read-modify-write (rmw) update, such
as \co{atomic_inc(&x)}, is atomic?
It means that the memory location (\co{x} in this case) does not get
altered between the read and the write events making up the atomic
operation.
In particular, if two CPUs perform \co{atomic_inc(&x)} concurrently,
it must be guaranteed that the final value of~\co{x} will be the
initial value plus two.
We should never have the following sequence of events:

\begin{VerbatimU}
	CPU 0 loads x obtaining 13;
	                                CPU 1 loads x obtaining 13;
	CPU 0 stores 14 to x;
	                                CPU 1 stores 14 to x;
\end{VerbatimU}

\noindent%
where the final value of~\co{x} is wrong (14~rather than~15).

In this example, CPU~0's increment effectively gets lost because it
occurs in between CPU~1's load and store.
To put it another way, the problem is that the position of CPU~0's
store in \co{x}'s coherence order is between the store that CPU~1
reads from and the store that CPU~1 performs.

The same analysis applies to all atomic update operations.
Therefore, to enforce atomicity the LKMM requires that atomic
updates follow this rule:
Whenever \co{R} and~\co{W} are the read and write events composing an
atomic read-modify-write and \co{W'}~is the write event which \co{R}~reads from,
there must not be any stores coming between~\co{W'} and~\co{W} in the coherence
order.
Equivalently,

\begin{VerbatimU}
	(R ->rmw W) implies (there is no X with R ->fr X and X ->co W)
\end{VerbatimU}

\noindent%
where the rmw relation links the read and write events making up each
atomic update.
This is what the LKMM's ``atomic'' axiom says.

Atomic rmw updates play one more role in the LKMM\@:
They can form ``rmw sequences''.
An rmw sequence is simply a bunch of atomic updates where
each update reads from the previous one.
Written using events, it looks like this:

\begin{VerbatimU}
	Z0 ->rf Y1 ->rmw Z1 ->rf ... ->rf Yn ->rmw Zn
\end{VerbatimU}

\noindent%
where \co{Z0} is some store event and \co{n} can be any number (even~\co{0}, in the
degenerate case).
We write this relation as{:} \qtco{Z0 ->rmw-sequence Zn}.
Note that this implies \co{Z0} and \co{Zn} are stores to the same variable.

Rmw sequences have a special property in the LKMM\@:
They can extend the \co{cumul-fence} relation.
That is, if we have:

\begin{VerbatimU}
	U ->cumul-fence X -> rmw-sequence Y
\end{VerbatimU}

\noindent%
then also \qtco{U ->cumul-fence Y}.  Thinking about this in terms of the
operational model, \qtco{U ->cumul-fence X} says that the store~\co{U} propagates
to each CPU before the store~\co{X} does.
Then the fact that \co{X} and~\co{Y} are linked by an rmw sequence
means that \co{U} also propagates to each CPU before \co{Y}~does.
In an analogous way, rmw sequences can also extend the
\co{w-post-bounded} relation defined below
in \cref{sec:docs:explanation:Plain Accesses and Data Races}.

(The notion of rmw sequences in the LKMM is similar to, but not quite
the same as, that of release sequences in the C11 memory model.
They were added to the LKMM to fix an obscure bug; without them, atomic
updates with full-barrier semantics did not always guarantee ordering
at least as strong as atomic updates with release-barrier semantics.)


\subsection{The preserved program order relation: \co{ppo}}
\label{sec:docs:explanation:The Preserved Program Order Relation: ppo}

There are many situations where a CPU is obliged to execute two
instructions in program order.
We amalgamate them into the ppo (for ``preserved program order'')
relation, which links the po-earlier instruction to the po-later
instruction and is thus a sub-relation of po.

The operational model already includes a description of one such
situation:
Fences are a source of ppo links.
Suppose \co{X} and~\co{Y} are memory accesses with \qtco{X ->po Y};
then the CPU must execute~\co{X} before~\co{Y} if any of the following hold:

\begin{itemize}
\item	A strong (\co{smp_mb()} or \co{synchronize_rcu()}) fence occurs between
	\co{X} and~\co{Y};

\item	\co{X} and~\co{Y} are both stores and an \co{smp_wmb()} fence occurs between
	them;

\item	\co{X} and~\co{Y} are both loads and an \co{smp_rmb()} fence occurs between
	them;

\item	\co{X} is also an acquire fence, such as \co{smp_load_acquire()};

\item	\co{Y} is also a release fence, such as \co{smp_store_release()}.
\end{itemize}

Another possibility, not mentioned earlier but discussed in the next
section, is:

\begin{itemize}
\item	\co{X} and~\co{Y} are both loads, \qtco{X ->addr Y} (i.e., there is an address
	dependency from~\co{X} to~\co{Y}), and \co{X}~is a \co{READ_ONCE()} or an atomic
	access.
\end{itemize}

Dependencies can also cause instructions to be executed in program
order.
This is uncontroversial when the second instruction is a
store; either a data, address, or control dependency from a load~\co{R} to
a store~\co{W} will force the CPU to execute \co{R} before~\co{W}.
This is very
simply because the CPU cannot tell the memory subsystem about \co{W}'s
store before it knows what value should be stored (in the case of a
data dependency), what location it should be stored into (in the case
of an address dependency), or whether the store should actually take
place (in the case of a control dependency).

Dependencies to load instructions are more problematic.
To begin with,
there is no such thing as a data dependency to a load.
Next, a CPU has no reason to respect a control dependency to a load, because it
can always satisfy the second load speculatively before the first, and
then ignore the result if it turns out that the second load shouldn't
be executed after all.
And lastly, the real difficulties begin when
we consider address dependencies to loads.

To be fair about it, all Linux-supported architectures do execute
loads in program order if there is an address dependency between them.
After all, a CPU cannot ask the memory subsystem to load a value from
a particular location before it knows what that location is.
However,
the split-cache design used by Alpha can cause it to behave in a way
that looks as if the loads were executed out of order (see the next
section for more details).
The kernel includes a workaround for this
problem when the loads come from \co{READ_ONCE()}, and therefore the LKMM
includes address dependencies to loads in the ppo relation.

On the other hand, dependencies can indirectly affect the ordering of
two loads.
This happens when there is a dependency from a load to a
store and a second, po-later load reads from that store:

\begin{VerbatimU}
	R ->dep W ->rfi R'
\end{VerbatimU}

\noindent%
where the dep link can be either an address or a data dependency.
In this situation we know it is possible for the CPU to execute~\co{R'}
before~\co{W}, because it can forward the value that W will store to~\co{R'}.
But it cannot execute \co{R'} before~\co{R}, because it cannot forward the value before
it knows what that value is, or that \co{W} and~\co{R'} do access the same
location.
However, if there is merely a control dependency between \co{R}
and~\co{W} then the CPU can speculatively forward W to~\co{R'} before
executing~\co{R}; if the speculation turns out to be wrong then the
CPU merely has to restart or abandon~\co{R'}.

(In theory, a CPU might forward a store to a load when it runs across
an address dependency like this:

\begin{VerbatimU}
	r1 = READ_ONCE(ptr);
	WRITE_ONCE(*r1, 17);
	r2 = READ_ONCE(*r1);
\end{VerbatimU}

\noindent%
because it could tell that the store and the second load access the
same location even before it knows what the location's address is.
However, none of the architectures supported by the Linux kernel do
this.)

Two memory accesses of the same location must always be executed in
program order if the second access is a store.
Thus, if we have

\begin{VerbatimU}
	R ->po-loc W
\end{VerbatimU}

\noindent%
(the po-loc link says that \co{R}~comes before~\co{W} in program order and they
access the same location), the CPU is obliged to execute~\co{W} after~\co{R}.
If it executed~\co{W} first then the memory subsystem would respond to~\co{R}'s
read request with the value stored by~\co{W} (or an even later store), in
violation of the read-write coherence rule.
Similarly, if we had

\begin{VerbatimU}
	W ->po-loc W'
\end{VerbatimU}

\noindent%
and the CPU executed~\co{W'} before~\co{W}, then the memory subsystem would
put~\co{W'} before~\co{W} in the coherence order.
It would effectively cause \co{W} to overwrite~\co{W'}, in violation of
the write-write coherence rule.
(Interestingly, an early ARMv8 memory model, now obsolete, proposed
allowing out-of-order writes like this to occur.
The model avoided violating the write-write coherence rule by
requiring the CPU not to send the \co{W}~write to the memory subsystem at all!)


\subsection{And then there was Alpha}
\label{sec:docs:explanation:And Then There Was Alpha}

As mentioned above, the Alpha architecture is unique in that it does
not appear to respect address dependencies to loads.
This means that code such as the following:

\begin{VerbatimU}
	int x = 0;
	int y = -1;
	int *ptr = &y;

	P0()
	{
		WRITE_ONCE(x, 1);
		smp_wmb();
		WRITE_ONCE(ptr, &x);
	}

	P1()
	{
		int *r1;
		int r2;

		r1 = ptr;
		r2 = READ_ONCE(*r1);
	}
\end{VerbatimU}

\noindent%
can malfunction on Alpha systems (notice that \co{P1} uses an ordinary load
to read \co{ptr} instead of \co{READ_ONCE()}).
It is quite possible that \qco{r1 = &x} and \qco{r2 = 0} at the end,
in spite of the address dependency.

At first glance this doesn't seem to make sense.
We know that the \co{smp_wmb()} forces \co{P0}'s store to~\co{x} to
propagate to~\co{P1} before the store to~\co{ptr} does.
And since \co{P1} can't execute its second load until it knows what
location to load from, i.e., after executing its first load,
the value \qco{x = 1} must have propagated to \co{P1} before the
second load executed.
So why doesn't \co{r2} end up equal to~1?

The answer lies in the Alpha's split local caches.
Although the two stores do reach \co{P1}'s local cache in the
proper order, it can happen that the first store is processed by a
busy part of the cache while the second store is processed by an
idle part.
As a result, the \qco{x = 1} value may not become available for
\co{P1}'s CPU to read until after the \qco{ptr = &x} value does,
leading to the undesirable result above.
The final effect is that even though the two loads really are
executed in program order, it appears that they aren't.

This could not have happened if the local cache had processed the
incoming stores in FIFO order.
By contrast, other architectures maintain at least the appearance of
FIFO order.

In practice, this difficulty is solved by inserting a special fence
between \co{P1}'s two loads when the kernel is compiled for the Alpha
architecture.
In fact, as of version 4.15, the kernel automatically adds this fence
after every \co{READ_ONCE()} and atomic load on Alpha.
The effect of the fence is to cause the CPU not to execute any po-later
instructions until after the local cache has finished processing all
the stores it has already received.
Thus, if the code was changed to:

\begin{VerbatimU}
	P1()
	{
		int *r1;
		int r2;

		r1 = READ_ONCE(ptr);
		r2 = READ_ONCE(*r1);
	}
\end{VerbatimU}

\noindent%
then we would never get \qco{r1 = &x} and \qco{r2 = 0}.
By the time \co{P1} executed its second load, the \qco{x = 1} store
would already be fully processed by the local cache and available for
satisfying the read request.
Thus we have yet another reason why shared data should always be read
with \co{READ_ONCE()} or another synchronization primitive rather than
accessed directly.

The LKMM requires that \co{smp_rmb()}, acquire fences, and strong fences
share this property:
They do not allow the CPU to execute any po-later instructions (or
po-later loads in the case of \co{smp_rmb()}) until all outstanding
stores have been processed by the local cache.
In the case of a strong fence, the CPU first has to wait for all of its
po-earlier stores to propagate to every other CPU in the system; then
it has to wait for the local cache to process all the stores received
as of that time---not just the stores received when the strong fence
began.

And of course, none of this matters for any architecture other than
Alpha.


\subsection{The happens-before relation: \co{hb}}
\label{sec:docs:explanation:The Happens-before Relation: hb}

The happens-before relation (\co{hb}) links memory accesses that have to
execute in a certain order.
\co{hb} includes the \co{ppo} relation and two others, one of which is \co{rfe}.

\qtco{W ->rfe R} implies that \co{W} and~\co{R} are on different CPUs.
It also means that \co{W}'s store must have propagated to \co{R}'s
CPU before \co{R}~executed; otherwise \co{R}~could not have read the
value stored by~\co{W}.
Therefore \co{W}~must have executed before~\co{R}, and so we have
\qtco{W ->hb R}.

The equivalent fact need not hold if \qtco{W ->rfi R}
(i.e., \co{W} and~\co{R} are on the same CPU\@).
As we have already seen, the operational model allows \co{W}'s value
to be forwarded to~\co{R} in such cases, meaning that \co{R}~may well
execute before \co{W}~does.

It's important to understand that neither \co{coe} nor \co{fre} is included in
\co{hb}, despite their similarities to~\co{rfe}.
For example, suppose we have \qtco{W ->coe W'}.
This means that \co{W} and~\co{W'} are stores to the same location,
they execute on different CPUs, and \co{W} comes before~\co{W'} in the coherence
order (i.e., \co{W'} overwrites~\co{W}).
Nevertheless, it is possible for \co{W'} to execute before~\co{W},
because the decision as to which store overwrites the other is made
later by the memory subsystem.
When the stores are nearly simultaneous, either one can come out on top.
Similarly, \qtco{R ->fre W} means that \co{W}~overwrites the value
which \co{R}~reads, but it doesn't mean that \co{W}~has to execute
after~\co{R}.
All that's necessary is for the memory subsystem not to propagate \co{W}
to \co{R}'s CPU until after \co{R} has executed, which is possible if
\co{W} executes shortly before~\co{R}.

The third relation included in \co{hb} is like \co{ppo}, in that it only links
events that are on the same CPU\@.
However it is more difficult to explain, because it arises only
indirectly from the requirement of cache coherence.
The relation is called \co{prop}, and it links two events on CPU~C
in situations where a store from some other CPU comes after the first
event in the coherence order and propagates to~C before the
second event executes.

This is best explained with some examples.
The simplest case looks like this:

\begin{VerbatimU}
	int x;

	P0()
	{
		int r1;

		WRITE_ONCE(x, 1);
		r1 = READ_ONCE(x);
	}

	P1()
	{
		WRITE_ONCE(x, 8);
	}
\end{VerbatimU}

If \qco{r1 = 8} at the end then \co{P0}'s accesses must have executed in program
order.
We can deduce this from the operational model; if \co{P0}'s load
had executed before its store then the value of the store would have
been forwarded to the load, so \co{r1} would have ended up equal to~1,
not~8.
In this case there is a \co{prop} link from \co{P0}'s write event to its read
event, because \co{P1}'s store came after \co{P0}'s store in \co{x}'s coherence
order, and \co{P1}'s store propagated to~\co{P0} before \co{P0}'s load executed.

An equally simple case involves two loads of the same location that
read from different stores:

\begin{VerbatimU}
	int x = 0;

	P0()
	{
		int r1, r2;

		r1 = READ_ONCE(x);
		r2 = READ_ONCE(x);
	}

	P1()
	{
		WRITE_ONCE(x, 9);
	}
\end{VerbatimU}

If \qco{r1 = 0} and \qco{r2 = 9} at the end then \co{P0}'s accesses
must have executed in program order.
If the second load had executed before the first then the \qco{x = 9}
store must have been propagated to \co{P0} before the first load
executed, and so \co{r1} would have been~9 rather than~0.
In this case there is a \co{prop} link from \co{P0}'s first read
event to its second, because \co{P1}'s store overwrote the value read
by \co{P0}'s first load, and \co{P1}'s store propagated to~\co{P0}
before \co{P0}'s second load executed.

Less trivial examples of \co{prop} all involve fences.
Unlike the simple examples above, they can require that some
instructions are executed out of program order.
This next one should look familiar:

\begin{VerbatimU}
	int buf = 0, flag = 0;

	P0()
	{
		WRITE_ONCE(buf, 1);
		smp_wmb();
		WRITE_ONCE(flag, 1);
	}

	P1()
	{
		int r1;
		int r2;

		r1 = READ_ONCE(flag);
		r2 = READ_ONCE(buf);
	}
\end{VerbatimU}

This is the MP pattern again, with an \co{smp_wmb()} fence between the two
stores.
If \qco{r1 = 1} and \qco{r2 = 0} at the end then there is a \co{prop} link
from \co{P1}'s second load to its first (backwards!).
The reason is similar to the previous examples:
The value \co{P1} loads from \co{buf} gets overwritten by \co{P0}'s
store to \co{buf}, the fence guarantees that the store to \co{buf}
will propagate to~\co{P1} before the store to \co{flag} does, and the
store to \co{flag} propagates to~\co{P1} before \co{P1} reads \co{flag}.

The \co{prop} link says that in order to obtain the \qco{r1 = 1, r2 = 0}
result, \co{P1} must execute its second load before the first.
Indeed, if the load from \co{flag} were executed first, then the
\qco{buf = 1} store would already have propagated to~\co{P1} by the
time \co{P1}'s load from \co{buf} executed, so \co{r2}~would have
been~1 at the end, not~0.
(The reasoning holds even for Alpha, although the details are more
complicated and we will not go into them.)

But what if we put an \co{smp_rmb()} fence between \co{P1}'s loads?
The fence would force the two loads to be executed in program order,
and it would generate a cycle in the \co{hb} relation:
The fence would create a \co{ppo} link (hence an \co{hb} link) from
the first load to the second, and the \co{prop} relation would give
an \co{hb} link from the second load to the first.
Since an instruction can't execute before itself, we are forced to
conclude that if an \co{smp_rmb()} fence is added, the \qco{r1 = 1, r2 = 0}
outcome is impossible---as it should be.

The formal definition of the \co{prop} relation involves a \co{coe}
or \co{fre} link, followed by an arbitrary number of \co{cumul-fence}
links, ending with an \co{rfe} link.
You can concoct more exotic examples, containing more than one fence,
although this quickly leads to diminishing returns in terms of complexity.
For instance, here's an example containing a \co{coe} link
followed by two \co{cumul-fences} and an \co{rfe} link, utilizing
the fact that release fences are A-cumulative:

\begin{VerbatimU}
	int x, y, z;

	P0()
	{
		int r0;

		WRITE_ONCE(x, 1);
		r0 = READ_ONCE(z);
	}

	P1()
	{
		WRITE_ONCE(x, 2);
		smp_wmb();
		WRITE_ONCE(y, 1);
	}

	P2()
	{
		int r2;

		r2 = READ_ONCE(y);
		smp_store_release(&z, 1);
	}
\end{VerbatimU}

If \qco{x = 2}, \qco{r0 = 1}, and \qco{r2 = 1} after this code runs
then there is a \co{prop} link from \co{P0}'s store to its load.
This is because \co{P0}'s store gets overwritten by \co{P1}'s store
since \qco{x = 2} at the end (a \co{coe} link), the \co{smp_wmb()}
ensures that \co{P1}'s store to~\co{x} propagates to~\co{P2} before the
store to~\co{y} does (the first \co{cumul-fence}), the store to~\co{y}
propagates to~\co{P2} before \co{P2}'s load and store execute,
\co{P2}'s \co{smp_store_release()} guarantees that the stores to~\co{x}
and~\co{y} both propagate to~\co{P0} before the store to~\co{z} does
(the second \co{cumul-fence}), and \co{P0}'s load executes after the
store to~\co{z} has propagated to~\co{P0} (an \co{rfe} link).

In summary, the fact that the \co{hb} relation links memory access events
in the order they execute means that it must not have cycles.
This requirement is the content of the LKMM's ``happens-before'' axiom.

The LKMM defines yet another relation connected to times of
instruction execution, but it is not included in \co{hb}.
It relies on the particular properties of strong fences, which we
cover in the next section.


\subsection{The propagates-before relation: \co{pb}}
\label{sec:docs:explanation:The Propagates-before Relation: pb}

The propagates-before (\co{pb}) relation capitalizes on the special
features of strong fences.
It links two events~\co{E} and~\co{F} whenever some store is
coherence-later than~\co{E} and propagates to every CPU and to RAM
before \co{F}~executes.
The formal definition requires that \co{E}~be linked to~\co{F}
via a \co{coe} or \co{fre} link, an arbitrary number of
\co{cumul-fences}, an optional \co{rfe} link, a strong fence, and
an arbitrary number of \co{hb} links.
Let's see how this definition works out.

Consider first the case where \co{E}~is a store (implying that the sequence
of links begins with \co{coe}).
Then there are events~\co{W}, \co{X}, \co{Y}, and~\co{Z} such that:

\begin{VerbatimU}
	E ->coe W ->cumul-fence* X ->rfe? Y ->strong-fence Z ->hb* F
\end{VerbatimU}

\noindent%
where the \qco{*} suffix indicates an arbitrary number of links of the
specified type, and the \qco{?} suffix indicates the link is optional
(\co{Y} may be equal to~\co{X}).
Because of the \co{cumul-fence} links, we know that \co{W}~will
propagate to \co{Y}'s~CPU before \co{X}~does, hence before
\co{Y}~executes and hence before the strong fence executes.
Because this fence is strong, we know that \co{W}~will propagate to
every CPU and to RAM before \co{Z}~executes.
And because of the \co{hb} links, we know that \co{Z}~will execute
before~\co{F}.
Thus \co{W}, which comes later than~\co{E} in the coherence order, will
propagate to every CPU and to RAM before \co{F}~executes.

The case where \co{E}~is a load is exactly the same, except that the first
link in the sequence is \co{fre} instead of~\co{coe}.

The existence of a \co{pb} link from~\co{E} to~\co{F} implies that
\co{E}~must execute before~\co{F}.
To see why, suppose that \co{F}~executed first.
Then \co{W}~would have propagated to \co{E's}~CPU before \co{E}~executed.
If \co{E}~was a store, the memory subsystem would then be forced to
make \co{E}~come after~\co{W} in the coherence order, contradicting
the fact that \qtco{E ->coe W}.
If \co{E}~was a load, the memory subsystem would then be forced to
satisfy \co{E}'s~read request with the value stored by~\co{W} or an
even later store, contradicting the fact that \qtco{E ->fre W}.

A good example illustrating how \co{pb} works is the SB pattern with strong
fences:

\begin{VerbatimU}
	int x = 0, y = 0;

	P0()
	{
		int r0;

		WRITE_ONCE(x, 1);
		smp_mb();
		r0 = READ_ONCE(y);
	}

	P1()
	{
		int r1;

		WRITE_ONCE(y, 1);
		smp_mb();
		r1 = READ_ONCE(x);
	}
\end{VerbatimU}

If \qco{r0 = 0} at the end then there is a \co{pb} link from \co{P0}'s~load
to \co{P1}'s~load{:} an \co{fre} link from \co{P0}'s~load to \co{P1}'s~store
(which overwrites the value read by~\co{P0}), and a strong fence
between \co{P1}'s~store and its load.
In this example, the sequences of \co{cumul-fence} and \co{hb} links are empty.
Note that this \co{pb} link is not included in \co{hb} as an instance
of~\co{prop}, because it does not start and end on the same CPU\@.

Similarly, if \qco{r1 = 0} at the end then there is a \co{pb}~link from
\co{P1}'s~load to~\co{P0}'s.
This means that if both \co{r1} and~\co{r2} were~0 there would be a
cycle in \co{hb}, which is not possible since an instruction cannot execute
before itself.
Thus, adding \co{smp_mb()} fences to the SB pattern prevents
the \qco{r0 = 0, r1 = 0} outcome.

In summary, the fact that the \co{pb}~relation links events in the order
they execute means that it cannot have cycles.
This requirement is the content of the LKMM's ``propagation'' axiom.


\subsection{RCU relations: \co{rcu-link}, \co{rcu-gp}, \co{rcu-rscsi}, \co{rcu-order}, \co{rcu-fence}, and \co{rb}}
\label{sec:docs:explanation:RCU Relations: rcu-link, rcu-gp, rcu-rscsi, rcu-order, rcu-fence, and rb}

RCU (Read-Copy-Update) is a powerful synchronization mechanism.
It rests on two concepts: grace periods and read-side critical sections.

A grace period is the span of time occupied by a call to
\co{synchronize_rcu()}.
A read-side critical section (or just critical section, for short) is
a region of code delimited by \co{rcu_read_lock()} at the start and
\co{rcu_read_unlock()} at the end.
Critical sections can be nested, although we won't make use of this fact.

As far as memory models are concerned, RCU's main feature is its
Grace-Period Guarantee, which states that a critical section can never
span a full grace period.
In more detail, the Guarantee says:

\begin{quote}
  For any critical section~C and any grace period~G, at least one of
  the following statements must hold:

  \begin{enumerate}
  \item	C ends before G does, and in addition, every store that
	propagates to C's~CPU before the end of~C must propagate to
	every CPU before G~ends.

  \item	G starts before C does, and in addition, every store that
	propagates to G's~CPU before the start of~G must propagate
	to every CPU before C~starts.
  \end{enumerate}
\end{quote}

In particular, it is not possible for a critical section to both start
before and end after a grace period.

Here is a simple example of RCU in action:

\begin{VerbatimU}
	int x, y;

	P0()
	{
		rcu_read_lock();
		WRITE_ONCE(x, 1);
		WRITE_ONCE(y, 1);
		rcu_read_unlock();
	}

	P1()
	{
		int r1, r2;

		r1 = READ_ONCE(x);
		synchronize_rcu();
		r2 = READ_ONCE(y);
	}
\end{VerbatimU}

The Grace Period Guarantee tells us that when this code runs, it will
never end with \qco{r1 = 1} and \qco{r2 = 0}.
The reasoning is as follows.
\qco{r1 = 1} means that \co{P0}'s store to~\co{x} propagated to~\co{P1}
before \co{P1}~called \co{synchronize_rcu()}, so \co{P0}'s~critical
section must have started before \co{P1}'s~grace period, contrary to
part~(2) of the Guarantee.
On the other hand, \qco{r2 = 0} means that \co{P0}'s store to~\co{y},
which occurs before the end of the critical section, did not propagate
to~\co{P1} before the end of the grace period, contrary to part~(1).
Together the results violate the Guarantee.

In the kernel's implementations of RCU, the requirements for stores
to propagate to every CPU are fulfilled by placing strong fences at
suitable places in the RCU-related code.
Thus, if a critical section starts before a grace period does then
the critical section's CPU will execute an \co{smp_mb()} fence after
the end of the critical section and some time before the grace
period's \co{synchronize_rcu()} call returns.
And if a critical section ends after a grace period does then the
\co{synchronize_rcu()} routine will execute an \co{smp_mb()} fence
at its start and some time before the critical section's opening
\co{rcu_read_lock()} executes.

What exactly do we mean by saying that a critical section ``starts
before'' or ``ends after'' a grace period?
Some aspects of the meaning are pretty obvious, as in the example
above, but the details aren't entirely clear.
The LKMM formalizes this notion by means of the \co{rcu-link} relation.
\co{rcu-link} encompasses a very general notion of ``before'':
If \co{E} and~\co{F} are RCU fence events (i.e., \co{rcu_read_lock()},
\co{rcu_read_unlock()}, or \co{synchronize_rcu()}) then among other things,
\qtco{E ->rcu-link F} includes cases where \co{E}~is po-before some
memory-access event~\co{X}, \co{F}~is po-after some memory-access
event~\co{Y}, and we have any of \qtco{X ->rfe Y}, \qtco{X ->co Y},
or \qtco{X ->fr Y}.

The formal definition of the \co{rcu-link} relation is more than a little
obscure, and we won't give it here.
It is closely related to the \co{pb} relation, and the details don't
matter unless you want to comb through a somewhat lengthy formal proof.
Pretty much all you need to know about \co{rcu-link} is the
information in the preceding paragraph.

The LKMM also defines the \co{rcu-gp} and \co{rcu-rscsi} relations.
They bring grace periods and read-side critical sections into the
picture, in the following way:

\begin{itemize}
\item	\qtco{E ->rcu-gp F} means that \co{E} and~\co{F} are in fact the
	same event, and that event is a \co{synchronize_rcu()} fence
	(i.e., a grace period).

\item	\qtco{E ->rcu-rscsi F} means that \co{E} and~\co{F} are the
	\co{rcu_read_unlock()} and \co{rcu_read_lock()} fence events
	delimiting some read-side critical section.
	(The \qco{i} at the end of the name emphasizes that this
	relation is ``inverted'':
	It links the end of the critical section to the start.)
\end{itemize}

If we think of the \co{rcu-link} relation as standing for an extended
``before'', then \qtco{X ->rcu-gp Y ->rcu-link Z} roughly says that \co{X}~is a
grace period which ends before \co{Z}~begins.
(In fact it covers more than this, because it also includes cases
where some store propagates to \co{Z}'s~CPU before \co{Z}~begins
but doesn't propagate to some other CPU until after \co{X}~ends.)
Similarly, \qtco{X ->rcu-rscsi Y ->rcu-link Z} says that \co{X}~is
the end of a critical section which starts before \co{Z}~begins.

The LKMM goes on to define the \co{rcu-order} relation as a sequence of
\co{rcu-gp} and \co{rcu-rscsi} links separated by \co{rcu-link} links,
in which the number of \co{rcu-gp} links is \co{>=} the number of
\co{rcu-rscsi} links.
For example:

\begin{VerbatimU}
	X ->rcu-gp Y ->rcu-link Z ->rcu-rscsi T ->rcu-link U ->rcu-gp V
\end{VerbatimU}

\noindent%
would imply that \qtco{X ->rcu-order V}, because this sequence contains two
\co{rcu-gp} links and one \co{rcu-rscsi} link.
(It also implies that \qtco{X ->rcu-order T} and \qtco{Z ->rcu-order V}.)
On the other hand:

\begin{VerbatimU}
	X ->rcu-rscsi Y ->rcu-link Z ->rcu-rscsi T ->rcu-link U ->rcu-gp V
\end{VerbatimU}

\noindent%
does not imply \qtco{X ->rcu-order V}, because the sequence contains only
one \co{rcu-gp} link but two \co{rcu-rscsi} links.

The \co{rcu-order} relation is important because the Grace Period Guarantee
means that \co{rcu-order} links act kind of like strong fences.
In particular, \qtco{E ->rcu-order F} implies not only that
\co{E}~begins before \co{F}~ends, but also that any write po-before~\co{E}
will propagate to every CPU before any instruction po-after~\co{F} can
execute.
(However, it does not imply that \co{E}~must execute before~\co{F};
in fact, each \co{synchronize_rcu()} fence event is linked to itself
by \co{rcu-order} as a degenerate case.)

To prove this in full generality requires some intellectual effort.
We'll consider just a very simple case:

\begin{VerbatimU}
	G ->rcu-gp W ->rcu-link Z ->rcu-rscsi F
\end{VerbatimU}

This formula means that \co{G} and~\co{W} are the same event (a grace period),
and there are events~\co{X}, \co{Y} and a read-side critical section~\co{C}
such that:

\begin{enumerate}
\item	\qco{G = W} is po-before or equal to~\co{X};

\item	\co{X} comes ``before''~\co{Y} in some sense (including \co{rfe},
	\co{co} and \co{fr});

\item	\co{Y} is po-before~\co{Z};

\item	\co{Z} is the \co{rcu_read_unlock()} event marking the end of~\co{C};

\item	\co{F} is the \co{rcu_read_lock()} event marking the start of~\co{C}.
\end{enumerate}

From 1--4 we deduce that the grace period~\co{G} ends before the critical
section~\co{C}.
Then part~(2) of the Grace Period Guarantee says not only that
\co{G}~starts before \co{C}~does, but also that any write which executes on
\co{G}'s~CPU before \co{G}~starts must propagate to every CPU before
\co{C}~starts.
In particular, the write propagates to every CPU before \co{F}~finishes
executing and hence before any instruction po-after~\co{F} can execute.
This sort of reasoning can be extended to handle all the situations
covered by \co{rcu-order}.

The \co{rcu-fence} relation is a simple extension of \co{rcu-order}.
While \co{rcu-order} only links certain fence events (calls to
\co{synchronize_rcu()}, \co{rcu_read_lock()}, or \co{rcu_read_unlock()}),
\co{rcu-fence} links any events that are separated by an \co{rcu-order} link.
This is analogous to the way the strong-fence relation links events
that are separated by an \co{smp_mb()} fence event (as mentioned above,
\co{rcu-order} links act kind of like strong fences).
Written symbolically, \qtco{X ->rcu-fence Y} means there are fence
events~\co{E} and~\co{F} such that:

\begin{VerbatimU}
	X ->po E ->rcu-order F ->po Y.
\end{VerbatimU}

From the discussion above, we see this implies not only that
\co{X}~executes before~\co{Y}, but also (if \co{X}~is a store)
that \co{X}~propagates to every CPU before \co{Y}~executes.
Thus \co{rcu-fence} is sort of a ``super-strong'' fence:
Unlike the original strong fences (\co{smp_mb()} and \co{synchronize_rcu()}),
\co{rcu-fence} is able to link events on different CPUs.
(Perhaps this fact should lead us to say that \co{rcu-fence} isn't
really a fence at all!)

Finally, the LKMM defines the RCU-before (\co{rb}) relation in terms of
\co{rcu-fence}.
This is done in essentially the same way as the \co{pb} relation was
defined in terms of strong-fence.
We will omit the details; the end result is that \qtco{E ->rb F}
implies \co{E}~must execute before~\co{F}, just as \qtco{E ->pb F}
does (and for much the same reasons).

Putting this all together, the LKMM expresses the Grace Period
Guarantee by requiring that the \co{rb} relation does not contain a cycle.
Equivalently, this ``rcu'' axiom requires that there are no events~\co{E}
and~\co{F} with \qtco{E ->rcu-link F ->rcu-order E}.
Or to put it a third way, the axiom requires that there are no cycles
consisting of \co{rcu-gp} and \co{rcu-rscsi} alternating with
\co{rcu-link}, where the number of \co{rcu-gp} links is \co{>=} the
number of \co{rcu-rscsi} links.

Justifying the axiom isn't easy, but it is in fact a valid
formalization of the Grace Period Guarantee.
We won't attempt to go through the detailed argument, but the
following analysis gives a taste of what is involved.
Suppose both parts of the Guarantee are violated:
A critical section starts before a grace period, and some store
propagates to the critical section's CPU before the end of the
critical section but doesn't propagate to some other CPU until after
the end of the grace period.

Putting symbols to these ideas, let \co{L} and~\co{U} be the
\co{rcu_read_lock()} and \co{rcu_read_unlock()} fence events
delimiting the critical section in question, and let \co{S}~be the
\co{synchronize_rcu()} fence event for the grace period.
Saying that the critical section starts before~\co{S} means there
are events~\co{Q} and~\co{R} where \co{Q}~is po-after~\co{L}
(which marks the start of the critical section), \co{Q}~is
``before''~\co{R} in the sense used by the \co{rcu-link} relation,
and \co{R}~is po-before the grace period~\co{S}.  Thus we have:

\begin{VerbatimU}
	L ->rcu-link S
\end{VerbatimU}

Let \co{W}~be the store mentioned above, let \co{Y}~come before
the end of the critical section and witness that \co{W}~propagates
to the critical section's CPU by reading from~\co{W}, and let \co{Z}~on
some arbitrary CPU be a witness that \co{W}~has not propagated to
that CPU, where \co{Z}~happens after some event~\co{X} which is
po-after~\co{S}.
Symbolically, this amounts to:

\begin{VerbatimU}
	S ->po X ->hb* Z ->fr W ->rf Y ->po U
\end{VerbatimU}

The \co{fr}~link from~\co{Z} to~\co{W} indicates that \co{W}~has not
propagated to \co{Z}'s~CPU at the time that \co{Z}~executes.
From this, it can be shown (see the discussion of the \co{rcu-link}
relation earlier) that \co{S} and~\co{U} are related by \co{rcu-link}:

\begin{VerbatimU}
	S ->rcu-link U
\end{VerbatimU}

Since \co{S}~is a grace period we have \qtco{S ->rcu-gp S}, and
since \co{L} and~\co{U} are the start and end of the critical
section~\co{C} we have \qtco{U ->rcu-rscsi L}.
From this we obtain:

\begin{VerbatimU}
	S ->rcu-gp S ->rcu-link U ->rcu-rscsi L ->rcu-link S
\end{VerbatimU}

\noindent%
a forbidden cycle.
Thus the ``rcu'' axiom rules out this violation of the Grace Period Guarantee.

For something a little more down-to-earth, let's see how the axiom
works out in practice.
Consider the RCU code example from above, this time with statement
labels added:

\begin{VerbatimU}
	int x, y;

	P0()
	{
		L: rcu_read_lock();
		X: WRITE_ONCE(x, 1);
		Y: WRITE_ONCE(y, 1);
		U: rcu_read_unlock();
	}

	P1()
	{
		int r1, r2;

		Z: r1 = READ_ONCE(x);
		S: synchronize_rcu();
		W: r2 = READ_ONCE(y);
	}
\end{VerbatimU}

If \qco{r2 = 0} at the end then \co{P0}'s~store at~\co{Y} overwrites
the value that \co{P1}'s~load at~\co{W} reads from, so we have
\qtco{W ->fre Y}.
Since \qtco{S ->po W} and also \qtco{Y ->po U}, we get \qtco{S ->rcu-link U}.
In addition, \qtco{S ->rcu-gp S} because \co{S}~is a grace period.

If \qco{r1 = 1} at the end then \co{P1}'s~load at~\co{Z} reads from
\co{P0}'s~store at~\co{X}, so we have \qtco{X ->rfe Z}.
Together with \qtco{L ->po X} and \qtco{Z ->po S}, this
yields \qtco{L ->rcu-link S}.
And since \co{L} and~\co{U} are the start and end of a
critical section, we have \qtco{U ->rcu-rscsi L}.

Then \qtco{U ->rcu-rscsi L ->rcu-link S ->rcu-gp S ->rcu-link U} is a
forbidden cycle, violating the ``rcu'' axiom.
Hence the outcome is not allowed by the LKMM, as we would expect.

For contrast, let's see what can happen in a more complicated example:

\begin{VerbatimU}[samepage=false]
	int x, y, z;

	P0()
	{
		int r0;

		L0: rcu_read_lock();
		    r0 = READ_ONCE(x);
		    WRITE_ONCE(y, 1);
		U0: rcu_read_unlock();
	}

	P1()
	{
		int r1;

		    r1 = READ_ONCE(y);
		S1: synchronize_rcu();
		    WRITE_ONCE(z, 1);
	}

	P2()
	{
		int r2;

		L2: rcu_read_lock();
		    r2 = READ_ONCE(z);
		    WRITE_ONCE(x, 1);
		U2: rcu_read_unlock();
	}
\end{VerbatimU}

If \qco{r0 = r1 = r2 = 1} at the end, then similar reasoning to before shows
that

\begin{VerbatimU}[breaklines=true]
U0 ->rcu-rscsi L0 ->rcu-link S1 ->rcu-gp S1 ->rcu-link U2 ->rcu-rscsi L2 ->rcu-link U0
\end{VerbatimU}

However this cycle is not forbidden, because the sequence of
relations contains fewer instances of \co{rcu-gp} (one) than of
\co{rcu-rscsi} (two).
Consequently the outcome is allowed by the LKMM\@.
The following instruction timing diagram shows how it might actually
occur:

\begin{VerbatimU}
P0                      P1                      P2
--------------------    --------------------    --------------------
rcu_read_lock()
WRITE_ONCE(y, 1)
                        r1 = READ_ONCE(y)
                        synchronize_rcu() starts
                        .                       rcu_read_lock()
                        .                       WRITE_ONCE(x, 1)
r0 = READ_ONCE(x)       .
rcu_read_unlock()       .
                        synchronize_rcu() ends
                        WRITE_ONCE(z, 1)
                                                r2 = READ_ONCE(z)
                                                rcu_read_unlock()
\end{VerbatimU}

This requires \co{P0} and~\co{P2} to execute their loads and stores out of
program order, but of course they are allowed to do so.
And as you can see, the Grace Period Guarantee is not violated:
The critical section in~\co{P0} both starts before \co{P1}'s~grace
period does and ends before it does, and the critical section in~\co{P2}
both starts after \co{P1}'s~grace period does and ends after it does.

The LKMM supports SRCU (Sleepable Read-Copy-Update) in addition to
normal RCU\@.
The ideas involved are much the same as above, with new
relations \co{srcu-gp} and \co{srcu-rscsi} added to represent SRCU
grace periods and read-side critical sections.
However, there are some significant differences between RCU read-side
critical sections and their SRCU counterparts, as described in the
next section.


\subsection{SRCU read-side critical sections}
\label{sec:docs:explanation:SRCU Read-side Critical Sections}

The LKMM uses the \co{srcu-rscsi} relation to model SRCU read-side critical
sections.
They differ from RCU read-side critical sections in the following respects:

\begin{enumerate}
\item	Unlike the analogous RCU primitives, \co{synchronize_srcu()},
	\co{srcu_read_lock()}, and \co{srcu_read_unlock()} take a pointer to a
	\co{struct srcu_struct} as an argument.
	This structure is called
	an SRCU domain, and calls linked by \co{srcu-rscsi} must have the
	same domain.
	Read-side critical sections and grace periods
	associated with different domains are independent of one
	another; the SRCU version of the RCU Guarantee applies only
	to pairs of critical sections and grace periods having the
	same domain.

\item	\co{srcu_read_lock()} returns a value, called the index, which must
	be passed to the matching \co{srcu_read_unlock()} call.
	Unlike
	\co{rcu_read_lock()} and \co{rcu_read_unlock()}, an \co{srcu_read_lock()}
	call does not always have to match the next unpaired
	\co{srcu_read_unlock()}.
	In fact, it is possible for two SRCU
	read-side critical sections to overlap partially, as in the
	following example (where \co{s}~is an~\co{srcu_struct}
	and \co{idx1} and~\co{idx2}
	are integer variables):

\begin{VerbatimU}
		idx1 = srcu_read_lock(&s);       // Start of first RSCS
		idx2 = srcu_read_lock(&s);       // Start of second RSCS
		srcu_read_unlock(&s, idx1);      // End of first RSCS
		srcu_read_unlock(&s, idx2);      // End of second RSCS
\end{VerbatimU}

	The matching is determined entirely by the domain pointer and
	index value.
	By contrast, if the calls had been
	\co{rcu_read_lock()} and \co{rcu_read_unlock()} then they would have
	created two nested (fully overlapping) read-side critical
	sections{:} an inner one and an outer one.

\item	The \co{srcu_down_read()} and \co{srcu_up_read()} primitives work
	exactly like \co{srcu_read_lock()} and \co{srcu_read_unlock()}, except
	that matching calls don't have to execute on the same CPU\@.
	(The names are meant to be suggestive of operations on
	semaphores.)
	Since the matching is determined by the domain
	pointer and index value, these primitives make it possible for
	an SRCU read-side critical section to start on one CPU and end
	on another, so to speak.
\end{enumerate}

In order to account for these properties of SRCU, the LKMM models
\co{srcu_read_lock()} as a special type of load event (which is
appropriate, since it takes a memory location as argument and returns
a value, just as a load does) and \co{srcu_read_unlock()} as a special type
of store event (again appropriate, since it takes as arguments a
memory location and a value).
These loads and stores are annotated as
belonging to the \qtco{srcu-lock} and \qtco{srcu-unlock} event classes
respectively.

This approach allows the LKMM to tell whether two events are
associated with the same SRCU domain, simply by checking whether they
access the same memory location (i.e., they are linked by the \co{loc}
relation).
It also gives a way to tell which unlock matches a
particular lock, by checking for the presence of a data dependency
from the load (\co{srcu-lock}) to the store (\co{srcu-unlock}).
For example,
given the situation outlined earlier (with statement labels added):

\begin{VerbatimU}
	A: idx1 = srcu_read_lock(&s);
	B: idx2 = srcu_read_lock(&s);
	C: srcu_read_unlock(&s, idx1);
	D: srcu_read_unlock(&s, idx2);
\end{VerbatimU}

\noindent%
the LKMM will treat \co{A} and~\co{B} as loads from~\co{s} yielding
values saved in
\co{idx1} and \co{idx2} respectively.
Similarly, it will treat \co{C} and~\co{D} as
though they stored the values from \co{idx1} and \co{idx2} in~\co{s}.
The end result
is much as if we had written:

\begin{VerbatimU}
	A: idx1 = READ_ONCE(s);
	B: idx2 = READ_ONCE(s);
	C: WRITE_ONCE(s, idx1);
	D: WRITE_ONCE(s, idx2);
\end{VerbatimU}

\noindent%
except for the presence of the special \co{srcu-lock} and \co{srcu-unlock}
annotations.
You can see at once that we have \qtco{A ->data C} and
\qtco{B ->data D}.
These dependencies tell the LKMM that \co{C}~is the
\co{srcu-unlock} event matching \co{srcu-lock} event~\co{A}, and \co{D}~is the
\co{srcu-unlock} event matching \co{srcu-lock} event~\co{B}.

This approach is admittedly a hack, and it has the potential to lead
to problems.
For example, in:

\begin{VerbatimU}
	idx1 = srcu_read_lock(&s);
	srcu_read_unlock(&s, idx1);
	idx2 = srcu_read_lock(&s);
	srcu_read_unlock(&s, idx2);
\end{VerbatimU}

\noindent%
the LKMM will believe that \co{idx2} must have the same value as~\co{idx1},
since it reads from the immediately preceding store of \co{idx1} in~\co{s}.
Fortunately this won't matter, assuming that litmus tests never do
anything with SRCU index values other than pass them to
\co{srcu_read_unlock()} or \co{srcu_up_read()} calls.

However, sometimes it is necessary to store an index value in a
shared variable temporarily.
In fact, this is the only way for
\co{srcu_down_read()} to pass the index it gets to an \co{srcu_up_read()} call
on a different CPU.
In more detail, we might have soething like:

\begin{VerbatimU}
	struct srcu_struct s;
	int x;

	P0()
	{
		int r0;

		A: r0 = srcu_down_read(&s);
		B: WRITE_ONCE(x, r0);
	}

	P1()
	{
		int r1;

		C: r1 = READ_ONCE(x);
		D: srcu_up_read(&s, r1);
	}
\end{VerbatimU}

Assuming that \co{P1}~executes after~\co{P0} and does read the index value
stored in~\co{x}, we can write this (using brackets to represent event
annotations) as:

\begin{VerbatimU}
	A[srcu-lock] ->data B[once] ->rf C[once] ->data D[srcu-unlock]
\end{VerbatimU}

The LKMM defines a \co{carry-srcu-data} relation to express this pattern;
it permits an arbitrarily long sequence of

\begin{VerbatimU}
	data ; rf
\end{VerbatimU}

\noindent%
pairs (that is, a data link followed by an \co{rf} link) to occur between
an \co{srcu-lock} event and the final data dependency leading to the
matching \co{srcu-unlock} event.
\co{carry-srcu-data} is complicated by the
need to ensure that none of the intermediate store events in this
sequence are instances of \co{srcu-unlock}.
This is necessary because in a
pattern like the one above:

\begin{VerbatimU}
	A: idx1 = srcu_read_lock(&s);
	B: srcu_read_unlock(&s, idx1);
	C: idx2 = srcu_read_lock(&s);
	D: srcu_read_unlock(&s, idx2);
\end{VerbatimU}

\noindent%
the LKMM treats \co{B}~as a store to the variable~\co{s} and
\co{C}~as a load from
that variable, creating an undesirable \co{rf} link from \co{B} to~\co{C}:

\begin{VerbatimU}
	A ->data B ->rf C ->data D.
\end{VerbatimU}

This would cause \co{carry-srcu-data} to mistakenly extend a data
dependency from~\co{A} to~\co{D}, giving the impression that \co{D}~was the
\co{srcu-unlock} event matching \co{A}'s~\co{srcu-lock}.
To avoid such problems,
\co{carry-srcu-data} does not accept sequences in which the ends of any of
the intermediate \co{->data} links (\co{B} above) is an \co{srcu-unlock} event.


\subsection{Locking}
\label{sec:docs:explanation:Locking}

The LKMM includes locking.
In fact, there is special code for locking
in the formal model, added in order to make tools run faster.
However, this special code is intended to be more or less equivalent
to concepts we have already covered.
A \co{spinlock_t} variable is treated
the same as an \co{int}, and \co{spin_lock(&s)} is treated almost the same as:

\begin{VerbatimU}
	while (cmpxchg_acquire(&s, 0, 1) != 0)
		cpu_relax();
\end{VerbatimU}

This waits until \co{s}~is equal to~0 and then atomically sets it to~1,
and the read part of the \co{cmpxchg} operation acts as an acquire fence.
An alternate way to express the same thing would be:

\begin{VerbatimU}
	r = xchg_acquire(&s, 1);
\end{VerbatimU}

\noindent%
along with a requirement that at the end, \qco{r = 0}.
Similarly,
\co{spin_trylock(&s)} is treated almost the same as:

\begin{VerbatimU}
	return !cmpxchg_acquire(&s, 0, 1);
\end{VerbatimU}

\noindent%
which atomically sets~\co{s} to~1 if it is currently equal to~0 and returns
\co{true} if it succeeds (the read part of the \co{cmpxchg} operation acts as an
acquire fence only if the operation is successful).
\co{spin_unlock(&s)}
is treated almost the same as:

\begin{VerbatimU}
	smp_store_release(&s, 0);
\end{VerbatimU}

The ``almost'' qualifiers above need some explanation.
In the LKMM, the
store-release in a \co{spin_unlock()} and the load-acquire which forms the
first half of the atomic rmw update in a \co{spin_lock()} or a successful
\co{spin_trylock()}---we can call these things lock-releases and
lock-acquires---have two properties beyond those of ordinary releases
and acquires.

First, when a lock-acquire reads from or is po-after a lock-release,
the LKMM requires that every instruction po-before the lock-release
must execute before any instruction po-after the lock-acquire.
This
would naturally hold if the release and acquire operations were on
different CPUs and accessed the same lock variable, but the LKMM says
it also holds when they are on the same CPU, even if they access
different lock variables.
For example:

\begin{VerbatimU}
	int x, y;
	spinlock_t s, t;

	P0()
	{
		int r1, r2;

		spin_lock(&s);
		r1 = READ_ONCE(x);
		spin_unlock(&s);
		spin_lock(&t);
		r2 = READ_ONCE(y);
		spin_unlock(&t);
	}

	P1()
	{
		WRITE_ONCE(y, 1);
		smp_wmb();
		WRITE_ONCE(x, 1);
	}
\end{VerbatimU}

Here the second \co{spin_lock()} is po-after the first \co{spin_unlock()}, and
therefore the load of~\co{x} must execute before the load of~\co{y}, even though
the two locking operations use different locks.
Thus we cannot have \qco{r1 = 1} and \qco{r2 = 0} at the end (this is
an instance of the MP pattern).

This requirement does not apply to ordinary release and acquire
fences, only to lock-related operations.
For instance, suppose \co{P0()}
in the example had been written as:

\begin{VerbatimU}
	P0()
	{
		int r1, r2, r3;

		r1 = READ_ONCE(x);
		smp_store_release(&s, 1);
		r3 = smp_load_acquire(&s);
		r2 = READ_ONCE(y);
	}
\end{VerbatimU}

Then the CPU would be allowed to forward the \qco{s = 1} value from the
\co{smp_store_release()} to the \co{smp_load_acquire()}, executing the
instructions in the following order:

\begin{VerbatimU}
		r3 = smp_load_acquire(&s);	// Obtains r3 = 1
		r2 = READ_ONCE(y);
		r1 = READ_ONCE(x);
		smp_store_release(&s, 1);	// Value is forwarded
\end{VerbatimU}

\noindent%
and thus it could load~\co{y} before~\co{x}, obtaining \qco{r2 = 0}
and \qco{r1 = 1}.

Second, when a lock-acquire reads from or is po-after a lock-release,
and some other stores~\co{W} and~\co{W'} occur po-before the lock-release and
po-after the lock-acquire respectively, the LKMM requires that \co{W}~must
propagate to each CPU before \co{W'} does.
For example, consider:

\begin{VerbatimU}
	int x, y;
	spinlock_t s;

	P0()
	{
		spin_lock(&s);
		WRITE_ONCE(x, 1);
		spin_unlock(&s);
	}

	P1()
	{
		int r1;

		spin_lock(&s);
		r1 = READ_ONCE(x);
		WRITE_ONCE(y, 1);
		spin_unlock(&s);
	}

	P2()
	{
		int r2, r3;

		r2 = READ_ONCE(y);
		smp_rmb();
		r3 = READ_ONCE(x);
	}
\end{VerbatimU}

If \qco{r1 = 1} at the end then the \co{spin_lock()} in~\co{P1} must
have read from
the \co{spin_unlock()} in~\co{P0}.
Hence the store to~\co{x} must propagate to~\co{P2}
before the store to~\co{y} does, so we cannot have \qco{r2 = 1} and
\qco{r3 = 0}.
But
if \co{P1}~had used a lock variable different from~\co{s}, the writes could have
propagated in either order.
(On the other hand, if the code in~\co{P0} and~\co{P1}
had all executed on a single CPU, as in the example before this
one, then the writes would have propagated in order even if the two
critical sections used different lock variables.)

These two special requirements for lock-release and lock-acquire do
not arise from the operational model.
Nevertheless, kernel developers
have come to expect and rely on them because they do hold on all
architectures supported by the Linux kernel, albeit for various
differing reasons.


\subsection{Plain accesses and data races}
\label{sec:docs:explanation:Plain Accesses and Data Races}

In the LKMM, memory accesses such as \co{READ_ONCE(x)}, \co{atomic_inc(&y)},
\co{smp_load_acquire(&z)}, and so on are collectively referred to as
``marked'' accesses, because they are all annotated with special
operations of one kind or another.
Ordinary C-language memory
accesses such as \qco{x} or \qco{y = 0} are simply called ``plain'' accesses.

Early versions of the LKMM had nothing to say about plain accesses.
The C~standard allows compilers to assume that the variables affected
by plain accesses are not concurrently read or written by any other
threads or CPUs.
This leaves compilers free to implement all manner
of transformations or optimizations of code containing plain accesses,
making such code very difficult for a memory model to handle.

Here is just one example of a possible pitfall:

\begin{VerbatimU}
	int a = 6;
	int *x = &a;

	P0()
	{
		int *r1;
		int r2 = 0;

		r1 = x;
		if (r1 != NULL)
			r2 = READ_ONCE(*r1);
	}

	P1()
	{
		WRITE_ONCE(x, NULL);
	}
\end{VerbatimU}

On the face of it, one would expect that when this code runs, the only
possible final values for \co{r2} are~6 and~0, depending on whether or not
\co{P1}'s~store to~\co{x} propagates to~\co{P0} before \co{P0}'s~load
from~\co{x} executes.
But since \co{P0}'s~load from~\co{x} is a plain access, the compiler may decide
to carry out the load twice (for the comparison against \co{NULL}, then again
for the \co{READ_ONCE()}) and eliminate the temporary variable~\co{r1}.
The object code generated for~\co{P0} could therefore end up looking rather
like this:

\begin{VerbatimU}
	P0()
	{
		int r2 = 0;

		if (x != NULL)
			r2 = READ_ONCE(*x);
	}
\end{VerbatimU}

And now it is obvious that this code runs the risk of dereferencing a
\co{NULL} pointer, because \co{P1}'s~store to~\co{x} might propagate
to~\co{P0} after the
test against \co{NULL} has been made but before the \co{READ_ONCE()} executes.
If the original code had said \qtco{r1 = READ_ONCE(x)} instead of \qco{r1 = x},
the compiler would not have performed this optimization and there
would be no possibility of a \co{NULL}-pointer dereference.

Given the possibility of transformations like this one, the LKMM
doesn't try to predict all possible outcomes of code containing plain
accesses.
It is instead content to determine whether the code
violates the compiler's assumptions, which would render the ultimate
outcome undefined.

In technical terms, the compiler is allowed to assume that when the
program executes, there will not be any data races.
A ``data race''
occurs when there are two memory accesses such that:

\begin{enumerate}
\item	they access the same location,

\item	at least one of them is a store,

\item	at least one of them is plain,

\item	they occur on different CPUs (or in different threads on the
	same CPU), and

\item	they execute concurrently.
\end{enumerate}

In the literature, two accesses are said to ``conflict'' if they satisfy
1 and~2 above.
We'll go a little farther and say that two accesses
are ``race candidates'' if they satisfy 1--4.
Thus, whether or not two
race candidates actually do race in a given execution depends on
whether they are concurrent.

The LKMM tries to determine whether a program contains race candidates
which may execute concurrently; if it does then the LKMM says there is
a potential data race and makes no predictions about the program's
outcome.

Determining whether two accesses are race candidates is easy; you can
see that all the concepts involved in the definition above are already
part of the memory model.
The hard part is telling whether they may
execute concurrently.
The LKMM takes a conservative attitude,
assuming that accesses may be concurrent unless it can prove they
are not.

If two memory accesses aren't concurrent then one must execute before
the other.
Therefore the LKMM decides two accesses aren't concurrent
if they can be connected by a sequence of \co{hb}, \co{pb}, and~\co{rb} links
(together referred to as \co{xb}, for ``executes before'').
However, there
are two complicating factors.

If \co{X} is a load and \co{X}~executes before a store~\co{Y}, then
indeed there is
no danger of \co{X} and~\co{Y} being concurrent.
After all, \co{Y}~can't have any
effect on the value obtained by~\co{X} until the memory subsystem has
propagated~\co{Y} from its own CPU to \co{X}'s~CPU, which won't happen until
some time after \co{Y}~executes and thus after \co{X} executes.
But if \co{X}~is a
store, then even if \co{X}~executes before~\co{Y} it is still possible
that \co{X}
will propagate to \co{Y}'s~CPU just as \co{Y}~is executing.
In such a case \co{X}~%
could very well interfere somehow with~\co{Y}, and we would have to
consider \co{X} and~\co{Y} to be concurrent.

Therefore when \co{X} is a store, for \co{X} and~\co{Y} to be
non-concurrent the LKMM
requires not only that \co{X}~must execute before~\co{Y} but also that
\co{X} must
propagate to \co{Y}'s~CPU before \co{Y}~executes.
(Or vice versa, of course, if
\co{Y}~executes before~\co{X}---then \co{Y} must propagate to
\co{X}'s~CPU before \co{X}~%
executes if \co{Y}~is a store.)
This is expressed by the visibility
relation (\co{vis}), where \qtco{X ->vis Y} is defined to hold if there is an
intermediate event~\co{Z} such that:

\begin{quote}
	\co{X} is connected to~\co{Z} by a possibly empty sequence of
	\co{cumul-fence} links followed by an optional \co{rfe} link (if none of
	these links are present, \co{X} and~\co{Z} are the same event),
\end{quote}

\noindent%
and either:

\begin{quote}
	\co{Z} is connected to~\co{Y} by a strong-fence link followed by a
	possibly empty sequence of \co{xb} links,
\end{quote}

\noindent%
or:

\begin{quote}
	\co{Z} is on the same CPU as~\co{Y} and is connected to~\co{Y}
        by a possibly
	empty sequence of \co{xb} links (again, if the sequence is empty it
	means \co{Z} and~\co{Y} are the same event).
\end{quote}

The motivations behind this definition are straightforward:

\begin{itemize}
\item	\co{cumul-fence} memory barriers force stores that are po-before
	the barrier to propagate to other CPUs before stores that are
	po-after the barrier.

\item	An \co{rfe} link from an event~\co{W} to an event~\co{R} says
	that \co{R}~reads
	from~\co{W}, which certainly means that \co{W}~must have propagated to
	\co{R}'s~CPU before \co{R}~executed.

\item	strong-fence memory barriers force stores that are po-before
	the barrier, or that propagate to the barrier's CPU before the
	barrier executes, to propagate to all CPUs before any events
	po-after the barrier can execute.
\end{itemize}

To see how this works out in practice, consider our old friend, the MP
pattern (with fences and statement labels, but without the conditional
test):

\begin{VerbatimU}
	int buf = 0, flag = 0;

	P0()
	{
		X: WRITE_ONCE(buf, 1);
		   smp_wmb();
		W: WRITE_ONCE(flag, 1);
	}

	P1()
	{
		int r1;
		int r2 = 0;

		Z: r1 = READ_ONCE(flag);
		   smp_rmb();
		Y: r2 = READ_ONCE(buf);
	}
\end{VerbatimU}

The \co{smp_wmb()} memory barrier gives a \co{cumul-fence} link
from~\co{X} to~\co{W}, and
assuming \qco{r1 = 1} at the end, there is an \co{rfe} link from~\co{W}
to~\co{Z}.
This
means that the store to \co{buf} must propagate from~\co{P0} to~\co{P1}
before \co{Z}~%
executes.
Next, \co{Z} and~\co{Y} are on the same CPU and the \co{smp_rmb()} fence
provides an \co{xb}~link from~\co{Z} to~\co{Y} (i.e., it forces~\co{Z}
to execute before~%
\co{Y}).
Therefore we have \qtco{X ->vis Y}:
\co{X} must propagate to \co{Y}'s~CPU before \co{Y}~%
executes.

The second complicating factor mentioned above arises from the fact
that when we are considering data races, some of the memory accesses
are plain.
Now, although we have not said so explicitly, up to this
point most of the relations defined by the LKMM (\co{ppo}, \co{hb}, \co{prop},
\co{cumul-fence}, \co{pb}, and so on---including \co{vis}) apply only to marked
accesses.

There are good reasons for this restriction.
The compiler is not
allowed to apply fancy transformations to marked accesses, and
consequently each such access in the source code corresponds more or
less directly to a single machine instruction in the object code.
But
plain accesses are a different story; the compiler may combine them,
split them up, duplicate them, eliminate them, invent new ones, and
who knows what else.
Seeing a plain access in the source code tells
you almost nothing about what machine instructions will end up in the
object code.

Fortunately, the compiler isn't completely free; it is subject to some
limitations.
For one, it is not allowed to introduce a data race into
the object code if the source code does not already contain a data
race (if it could, memory models would be useless and no multithreaded
code would be safe!).
For another, it cannot move a plain access past
a compiler barrier.

A compiler barrier is a kind of fence, but as the name implies, it
only affects the compiler; it does not necessarily have any effect on
how instructions are executed by the CPU\@.
In Linux kernel source
code, the \co{barrier()} function is a compiler barrier.
It doesn't give
rise directly to any machine instructions in the object code; rather,
it affects how the compiler generates the rest of the object code.
Given source code like this:

\begin{VerbatimU}
	... some memory accesses ...
	barrier();
	... some other memory accesses ...
\end{VerbatimU}

the \co{barrier()} function ensures that the machine instructions
corresponding to the first group of accesses will all end po-before
any machine instructions corresponding to the second group of accesses%
---even if some of the accesses are plain.
(Of course, the CPU may
then execute some of those accesses out of program order, but we
already know how to deal with such issues.)
Without the \co{barrier()}
there would be no such guarantee; the two groups of accesses could be
intermingled or even reversed in the object code.

The LKMM doesn't say much about the \co{barrier()} function, but it does
require that all fences are also compiler barriers.
In addition, it
requires that the ordering properties of memory barriers such as
\co{smp_rmb()} or \co{smp_store_release()} apply to plain accesses as well as to
marked accesses.

This is the key to analyzing data races.
Consider the MP pattern
again, now using plain accesses for buf:

\begin{VerbatimU}
	int buf = 0, flag = 0;

	P0()
	{
		U: buf = 1;
		   smp_wmb();
		X: WRITE_ONCE(flag, 1);
	}

	P1()
	{
		int r1;
		int r2 = 0;

		Y: r1 = READ_ONCE(flag);
		   if (r1) {
			   smp_rmb();
			V: r2 = buf;
		   }
	}
\end{VerbatimU}

This program does not contain a data race.
Although the \co{U} and~\co{V}
accesses are race candidates, the LKMM can prove they are not
concurrent as follows:

\begin{quote}
	The \co{smp_wmb()} fence in \co{P0} is both a compiler barrier and a
	\co{cumul-fence.}
	It guarantees that no matter what hash of
	machine instructions the compiler generates for the plain
	access~\co{U}, all those instructions will be po-before the fence.
	Consequently \co{U}'s~store to~\co{buf}, no matter how it is carried out
	at the machine level, must propagate to~\co{P1} before \co{X}'s~store to
	\co{flag} does.

	\co{X} and~\co{Y} are both marked accesses.
	Hence an \co{rfe} link from~\co{X} to~%
	\co{Y} is a valid indicator that \co{X}~propagated to~\co{P1}
	before \co{Y}
	executed, i.e., \qtco{X ->vis Y}.  (And if there is no \co{rfe} link then
	\co{r1} will be~0, so \co{V}~will not be executed and ipso facto won't
	race with~\co{U}.)

	The \co{smp_rmb()} fence in \co{P1} is a compiler barrier as well as a
	fence.
	It guarantees that all the machine-level instructions
	corresponding to the access~\co{V} will be po-after the fence, and
	therefore any loads among those instructions will execute
	after the fence does and hence after \co{Y}~does.
\end{quote}

Thus \co{U}'s store to \co{buf} is forced to propagate to~\co{P1}
before \co{V}'s~load
executes (assuming \co{V}~does execute), ruling out the possibility of a
data race between them.

This analysis illustrates how the LKMM deals with plain accesses in
general.
Suppose \co{R} is a plain load and we want to show that \co{R}~%
executes before some marked access~\co{E}.  We can do this by finding a
marked access~\co{X} such that \co{R} and~\co{X} are ordered by
a suitable fence and
\qtco{X ->xb* E}.
If \co{E} was also a plain access, we would also look for a
marked access~\co{Y} such that \qtco{X ->xb* Y}, and \co{Y} and~\co{E}
are ordered by a
fence.
We describe this arrangement by saying that \co{R}~is
``post-bounded'' by~\co{X} and \co{E}~is ``pre-bounded'' by~\co{Y}.

In fact, we go one step further:
Since \co{R}~is a read, we say that \co{R}~is
``r-post-bounded'' by~\co{X}.
Similarly, \co{E}~would be ``r-pre-bounded'' or
``w-pre-bounded'' by~\co{Y}, depending on whether \co{E}~was a store or a load.
This distinction is needed because some fences affect only loads
(i.e., \co{smp_rmb()}) and some affect only stores (\co{smp_wmb()}); otherwise
the two types of bounds are the same.
And as a degenerate case, we
say that a marked access pre-bounds and post-bounds itself (e.g., if \co{R}~%
above were a marked load then \co{X}~could simply be taken to be \co{R}~itself.)

The need to distinguish between r- and w-bounding raises yet another
issue.
When the source code contains a plain store, the compiler is
allowed to put plain loads of the same location into the object code.
For example, given the source code:

\begin{VerbatimU}
	x = 1;
\end{VerbatimU}

\noindent%
the compiler is theoretically allowed to generate object code that
looks like:

\begin{VerbatimU}
	if (x != 1)
		x = 1;
\end{VerbatimU}

\noindent%
thereby adding a load (and possibly replacing the store entirely).
For this reason, whenever the LKMM requires a plain store to be
w-pre-bounded or w-post-bounded by a marked access, it also requires
the store to be r-pre-bounded or r-post-bounded, so as to handle cases
where the compiler adds a load.

(This may be overly cautious.
We don't know of any examples where a
compiler has augmented a store with a load in this fashion, and the
Linux kernel developers would probably fight pretty hard to change a
compiler if it ever did this.
Still, better safe than sorry.)

Incidentally, the other tranformation---augmenting a plain load by
adding in a store to the same location---is not allowed.
This is
because the compiler cannot know whether any other CPUs might perform
a concurrent load from that location.
Two concurrent loads don't
constitute a race (they can't interfere with each other), but a store
does race with a concurrent load.
Thus adding a store might create a
data race where one was not already present in the source code,
something the compiler is forbidden to do.
Augmenting a store with a
load, on the other hand, is acceptable because doing so won't create a
data race unless one already existed.

The LKMM includes a second way to pre-bound plain accesses, in
addition to fences{:} an address dependency from a marked load.
That
is, in the sequence:

\begin{VerbatimU}
	p = READ_ONCE(ptr);
	r = *p;
\end{VerbatimU}

\noindent%
the LKMM says that the marked load of~\co{ptr} pre-bounds the plain load of~%
\co{*p}; the marked load must execute before any of the machine
instructions corresponding to the plain load.
This is a reasonable
stipulation, since after all, the CPU can't perform the load of~\co{*p}
until it knows what value \co{p}~will hold.
Furthermore, without some
assumption like this one, some usages typical of RCU would count as
data races.
For example:

\begin{VerbatimU}
	int a = 1, b;
	int *ptr = &a;

	P0()
	{
		b = 2;
		rcu_assign_pointer(ptr, &b);
	}

	P1()
	{
		int *p;
		int r;

		rcu_read_lock();
		p = rcu_dereference(ptr);
		r = *p;
		rcu_read_unlock();
	}
\end{VerbatimU}

(In this example the \co{rcu_read_lock()} and \co{rcu_read_unlock()} calls don't
really do anything, because there aren't any grace periods.
They are
included merely for the sake of good form; typically \co{P0}~would call
\co{synchronize_rcu()} somewhere after the \co{rcu_assign_pointer()}.)

\co{rcu_assign_pointer()} performs a store-release, so the plain store to~\co{b}
is definitely w-post-bounded before the store to~\co{ptr}, and the two
stores will propagate to~\co{P1} in that order.
However, \co{rcu_dereference()}
is only equivalent to \co{READ_ONCE()}.
While it is a marked access, it is not a fence or compiler barrier.
Hence the only guarantee we have
that the load of~\co{ptr} in~\co{P1} is r-pre-bounded before the load of~\co{*p}
(thus avoiding a race) is the assumption about address dependencies.

This is a situation where the compiler can undermine the memory model,
and a certain amount of care is required when programming constructs
like this one.
In particular, comparisons between the pointer and
other known addresses can cause trouble.
If you have something like:

\begin{VerbatimU}
	p = rcu_dereference(ptr);
	if (p == &x)
		r = *p;
\end{VerbatimU}

\noindent%
then the compiler just might generate object code resembling:

\begin{VerbatimU}
	p = rcu_dereference(ptr);
	if (p == &x)
		r = x;
\end{VerbatimU}

\noindent%
or even:

\begin{VerbatimU}
	rtemp = x;
	p = rcu_dereference(ptr);
	if (p == &x)
		r = rtemp;
\end{VerbatimU}

\noindent%
which would invalidate the memory model's assumption, since the CPU
could now perform the load of~\co{x} before the load of~\co{ptr} (there might be
a control dependency but no address dependency at the machine level).

Finally, it turns out there is a situation in which a plain write does
not need to be w-post-bounded{:} when it is separated from the other
race-candidate access by a fence.
At first glance this may seem
impossible.
After all, to be race candidates the two accesses must
be on different CPUs, and fences don't link events on different CPUs.
Well, normal fences don't---but \co{rcu-fence} can!
Here's an example:

\begin{VerbatimU}
	int x, y;

	P0()
	{
		WRITE_ONCE(x, 1);
		synchronize_rcu();
		y = 3;
	}

	P1()
	{
		rcu_read_lock();
		if (READ_ONCE(x) == 0)
			y = 2;
		rcu_read_unlock();
	}
\end{VerbatimU}

Do the plain stores to~\co{y} race?  Clearly not if \co{P1}~reads a non-zero
value for~\co{x}, so let's assume the \co{READ_ONCE(x)} does obtain~0.
This
means that the read-side critical section in~\co{P1} must finish executing
before the grace period in~\co{P0} does, because RCU's Grace-Period
Guarantee says that otherwise \co{P0}'s~store to~\co{x} would have
propagated to~%
\co{P1} before the critical section started and so would have been visible
to the \co{READ_ONCE()}.
(Another way of putting it is that the fre link
from the \co{READ_ONCE()} to the \co{WRITE_ONCE()} gives rise to an
\co{rcu-link}
between those two events.)

This means there is an \co{rcu-fence} link from \co{P1}'s \qco{y = 2} store
to \co{P0}'s \qco{y = 3} store, and consequently the first must propagate
from~\co{P1} to~\co{P0}
before the second can execute.
Therefore the two stores cannot be
concurrent and there is no race, even though \co{P1}'s~plain store to~\co{y}
isn't w-post-bounded by any marked accesses.

Putting all this material together yields the following picture.
For
race-candidate stores~\co{W} and~\co{W'}, where \qtco{W ->co W'},
the LKMM says the
stores don't race if \co{W}~can be linked to~\co{W'} by a

\begin{VerbatimU}
	w-post-bounded ; vis ; w-pre-bounded
\end{VerbatimU}

\noindent%
sequence.
If \co{W}~is plain then they also have to be linked by an

\begin{VerbatimU}
	r-post-bounded ; xb* ; w-pre-bounded
\end{VerbatimU}

\noindent%
sequence, and if \co{W'}~is plain then they also have to be linked by a

\begin{VerbatimU}
	w-post-bounded ; vis ; r-pre-bounded
\end{VerbatimU}

\noindent%
sequence.
For race-candidate load~\co{R} and store~\co{W}, the LKMM says the
two accesses don't race if \co{R}~can be linked to~\co{W} by an

\begin{VerbatimU}
	r-post-bounded ; xb* ; w-pre-bounded
\end{VerbatimU}

\noindent%
sequence or if \co{W}~can be linked to~\co{R} by a

\begin{VerbatimU}
	w-post-bounded ; vis ; r-pre-bounded
\end{VerbatimU}

\noindent%
sequence.
For the cases involving a \co{vis} link, the LKMM also accepts
sequences in which \co{W}~is linked to~\co{W'} or~\co{R} by a

\begin{VerbatimU}
	strong-fence ; xb* ; {w and/or r}-pre-bounded
\end{VerbatimU}

\noindent%
sequence with no post-bounding, and in every case the LKMM also allows
the link simply to be a fence with no bounding at all.
If no sequence
of the appropriate sort exists, the LKMM says that the accesses race.

There is one more part of the LKMM related to plain accesses (although
not to data races) we should discuss.
Recall that many relations such
as \co{hb} are limited to marked accesses only.
As a result, the
happens-before, propagates-before, and rcu axioms (which state that
various relation must not contain a cycle) doesn't apply to plain
accesses.
Nevertheless, we do want to rule out such cycles, because
they don't make sense even for plain accesses.

To this end, the LKMM imposes three extra restrictions, together
called the ``plain-coherence'' axiom because of their resemblance to the
rules used by the operational model to ensure cache coherence (that
is, the rules governing the memory subsystem's choice of a store to
satisfy a load request and its determination of where a store will
fall in the coherence order):

\begin{itemize}
\item	If \co{R} and~\co{W} are race candidates and it is possible to
	link~\co{R} to~%
	\co{W} by one of the \co{xb*} sequences listed above, then
	\qtco{W ->rfe R} is
	not allowed (i.e., a load cannot read from a store that it
	executes before, even if one or both is plain).

\item	If \co{W} and~\co{R} are race candidates and it is possible to
	link~\co{W} to~%
	\co{R} by one of the \co{vis} sequences listed above, then
	\qtco{R ->fre W} is
	not allowed (i.e., if a store is visible to a load then the
	load must read from that store or one coherence-after it).

\item	If \co{W} and~\co{W'} are race candidates and it is possible to
	link~\co{W}
	to~\co{W'} by one of the \co{vis} sequences listed above, then
	\qtco{W' ->co W}
	is not allowed (i.e., if one store is visible to a second then
	the second must come after the first in the coherence order).
\end{itemize}

This is the extent to which the LKMM deals with plain accesses.
Perhaps it could say more (for example, plain accesses might
contribute to the \co{ppo} relation), but at the moment it seems that this
minimal, conservative approach is good enough.


\subsection{Odds and ends}
\label{sec:docs:explanation:Odds and Ends}

This section covers material that didn't quite fit anywhere in the
earlier sections.

The descriptions in this document don't always match the formal
version of the LKMM exactly.
For example, the actual formal
definition of the \co{prop} relation makes the initial \co{coe} or~\co{fre} part
optional, and it doesn't require the events linked by the relation to
be on the same CPU\@.
These differences are very unimportant; indeed,
instances where the \co{coe}/\co{fre} part of \co{prop} is missing
are of no interest
because all the other parts (fences and \co{rfe}) are already included in~%
\co{hb} anyway, and where the formal model adds \co{prop} into~\co{hb},
it includes
an explicit requirement that the events being linked are on the same
CPU\@.

Another minor difference has to do with events that are both memory
accesses and fences, such as those corresponding to \co{smp_load_acquire()}
calls.
In the formal model, these events aren't actually both reads
and fences; rather, they are read events with an annotation marking
them as acquires.
(Or write events annotated as releases, in the case
\co{smp_store_release()}.)
The final effect is the same.

Although we didn't mention it above, the instruction execution
ordering provided by the \co{smp_rmb()} fence doesn't apply to read events
that are part of a non-value-returning atomic update.
For instance,
given:

\begin{VerbatimU}
	atomic_inc(&x);
	smp_rmb();
	r1 = READ_ONCE(y);
\end{VerbatimU}

\noindent%
it is not guaranteed that the load from~\co{y} will execute after the
update to~\co{x}.
This is because the ARMv8 architecture allows
non-value-returning atomic operations effectively to be executed off
the CPU\@.
Basically, the CPU tells the memory subsystem to increment~%
\co{x}, and then the increment is carried out by the memory hardware with
no further involvement from the CPU\@.
Since the CPU doesn't ever read
the value of~\co{x}, there is nothing for the \co{smp_rmb()} fence to act on.

The LKMM defines a few extra synchronization operations in terms of
things we have already covered.
In particular, \co{rcu_dereference()} is
treated as \co{READ_ONCE()} and \co{rcu_assign_pointer()} is treated as
\co{smp_store_release()}---which is basically how the Linux kernel treats
them.

Although we said that plain accesses are not linked by the \co{ppo}
relation, they do contribute to it indirectly.
Firstly, when there is
an address dependency from a marked load~\co{R} to a plain store~\co{W},
followed by \co{smp_wmb()} and then a marked store~\co{W'}, the LKMM creates a
\co{ppo} link from~\co{R} to~{W'}.
The reasoning behind this is perhaps a little
shaky, but essentially it says there is no way to generate object code
for this source code in which \co{W'}~could execute before~\co{R}.
Just as with
pre-bounding by address dependencies, it is possible for the compiler
to undermine this relation if sufficient care is not taken.

Secondly, plain accesses can carry dependencies:
If a data dependency
links a marked load~\co{R} to a store~\co{W}, and the store is read
by a load~\co{R'}
from the same thread, then the data loaded by~\co{R'} depends on the data
loaded originally by~\co{R}.
Thus, if \co{R'}~is linked to any access~\co{X} by a
dependency, \co{R}~is also linked to access~\co{X} by the same dependency, even
if \co{W'} or~\co{R'} (or both{!}) are plain.

There are a few oddball fences which need special treatment:
\co{smp_mb__before_atomic()}, \co{smp_mb__after_atomic()}, and
\co{smp_mb__after_spinlock()}.
The LKMM uses fence events with special
annotations for them; they act as strong fences just like \co{smp_mb()}
except for the sets of events that they order.
Instead of ordering
all po-earlier events against all po-later events, as \co{smp_mb()} does,
they behave as follows:

\begin{itemize}
\item	\co{smp_mb__before_atomic()} orders all \co{po}-earlier events against
	\co{po}-later atomic updates and the events following them;

\item	\co{smp_mb__after_atomic()} orders \co{po}-earlier atomic updates and
	the events preceding them against all \co{po}-later events;

\item	\co{smp_mb__after_spinlock()} orders \co{po}-earlier lock acquisition
	events and the events preceding them against all \co{po}-later
	events.
\end{itemize}

Interestingly, RCU and locking each introduce the possibility of
deadlock.
When faced with code sequences such as:

\begin{VerbatimU}
	spin_lock(&s);
	spin_lock(&s);
	spin_unlock(&s);
	spin_unlock(&s);
\end{VerbatimU}

\noindent%
or:

\begin{VerbatimU}
	rcu_read_lock();
	synchronize_rcu();
	rcu_read_unlock();
\end{VerbatimU}

\noindent%
what does the LKMM have to say?
Answer:
It says there are no allowed
executions at all, which makes sense.
But this can also lead to
misleading results, because if a piece of code has multiple possible
executions, some of which deadlock, the model will report only on the
non-deadlocking executions.
For example:

\begin{VerbatimU}
	int x, y;

	P0()
	{
		int r0;

		WRITE_ONCE(x, 1);
		r0 = READ_ONCE(y);
	}

	P1()
	{
		rcu_read_lock();
		if (READ_ONCE(x) > 0) {
			WRITE_ONCE(y, 36);
			synchronize_rcu();
		}
		rcu_read_unlock();
	}
\end{VerbatimU}

Is it possible to end up with \qco{r0 = 36} at the end?
The LKMM will tell
you it is not, but the model won't mention that this is because \co{P1}~%
will self-deadlock in the executions where it stores~36 in~\co{y}.
